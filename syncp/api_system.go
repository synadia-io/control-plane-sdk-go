/*
Synadia Control Plane

API for Synadia Control Plane Server

API version: beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package syncp

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

type SystemAPI interface {

	/*
		AssignSystemTeamAppUser Assign Team App User to System

		Assign a Team App User to a System. This operation is idempotent; if an App User is already assigned to the System the assignment will be updated with the new role

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@param teamAppUserId
		@return ApiAssignSystemTeamAppUserRequest
	*/
	AssignSystemTeamAppUser(ctx context.Context, systemId string, teamAppUserId string) ApiAssignSystemTeamAppUserRequest

	// AssignSystemTeamAppUserExecute executes the request
	//  @return AppUserAssignResponse
	AssignSystemTeamAppUserExecute(r ApiAssignSystemTeamAppUserRequest) (*AppUserAssignResponse, *http.Response, error)

	/*
		CreateAccount Create Account

		Create Account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiCreateAccountRequest
	*/
	CreateAccount(ctx context.Context, systemId string) ApiCreateAccountRequest

	// CreateAccountExecute executes the request
	//  @return AccountViewResponse
	CreateAccountExecute(r ApiCreateAccountRequest) (*AccountViewResponse, *http.Response, error)

	/*
		CreateSystemAlertRule Create System Alert Rule

		Create System Alert Rule

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiCreateSystemAlertRuleRequest
	*/
	CreateSystemAlertRule(ctx context.Context, systemId string) ApiCreateSystemAlertRuleRequest

	// CreateSystemAlertRuleExecute executes the request
	//  @return AlertRuleViewResponse
	CreateSystemAlertRuleExecute(r ApiCreateSystemAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error)

	/*
		DeleteSystem Delete System

		Deletes System

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiDeleteSystemRequest
	*/
	DeleteSystem(ctx context.Context, systemId string) ApiDeleteSystemRequest

	// DeleteSystemExecute executes the request
	DeleteSystemExecute(r ApiDeleteSystemRequest) (*http.Response, error)

	/*
		DeleteSystemAlertRule Delete System Alert Rule

		Delete System Alert rule

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@param alertRuleId
		@return ApiDeleteSystemAlertRuleRequest
	*/
	DeleteSystemAlertRule(ctx context.Context, systemId string, alertRuleId string) ApiDeleteSystemAlertRuleRequest

	// DeleteSystemAlertRuleExecute executes the request
	DeleteSystemAlertRuleExecute(r ApiDeleteSystemAlertRuleRequest) (*http.Response, error)

	/*
		DownloadSystemLogs Download Logs

		Download System Logs

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiDownloadSystemLogsRequest
	*/
	DownloadSystemLogs(ctx context.Context, systemId string) ApiDownloadSystemLogsRequest

	// DownloadSystemLogsExecute executes the request
	//  @return *os.File
	DownloadSystemLogsExecute(r ApiDownloadSystemLogsRequest) (*os.File, *http.Response, error)

	/*
		GetCurrentAgentToken Get Current Agent Token

		Get the Current Agent Token

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiGetCurrentAgentTokenRequest
	*/
	GetCurrentAgentToken(ctx context.Context, systemId string) ApiGetCurrentAgentTokenRequest

	// GetCurrentAgentTokenExecute executes the request
	//  @return AgentTokenCurrentResponse
	GetCurrentAgentTokenExecute(r ApiGetCurrentAgentTokenRequest) (*AgentTokenCurrentResponse, *http.Response, error)

	/*
		GetSystem Get System

		Returns a System by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiGetSystemRequest
	*/
	GetSystem(ctx context.Context, systemId string) ApiGetSystemRequest

	// GetSystemExecute executes the request
	//  @return SystemViewResponse
	GetSystemExecute(r ApiGetSystemRequest) (*SystemViewResponse, *http.Response, error)

	/*
		GetSystemAlertRule Get System Alert Rule

		Get System Alert Rule

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@param alertRuleId
		@return ApiGetSystemAlertRuleRequest
	*/
	GetSystemAlertRule(ctx context.Context, systemId string, alertRuleId string) ApiGetSystemAlertRuleRequest

	// GetSystemAlertRuleExecute executes the request
	//  @return AlertRuleViewResponse
	GetSystemAlertRuleExecute(r ApiGetSystemAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error)

	/*
		GetSystemLimits Get System Limits

		Get system total and allocated limits

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiGetSystemLimitsRequest
	*/
	GetSystemLimits(ctx context.Context, systemId string) ApiGetSystemLimitsRequest

	// GetSystemLimitsExecute executes the request
	//  @return SystemLimitsResponse
	GetSystemLimitsExecute(r ApiGetSystemLimitsRequest) (*SystemLimitsResponse, *http.Response, error)

	/*
		ImportAccount Import Account

		Imports an existing account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiImportAccountRequest
	*/
	ImportAccount(ctx context.Context, systemId string) ApiImportAccountRequest

	// ImportAccountExecute executes the request
	ImportAccountExecute(r ApiImportAccountRequest) (*http.Response, error)

	/*
		ImportUser Import User

		Imports an existing NATS user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiImportUserRequest
	*/
	ImportUser(ctx context.Context, systemId string) ApiImportUserRequest

	// ImportUserExecute executes the request
	//  @return NatsUserViewResponse
	ImportUserExecute(r ApiImportUserRequest) (*NatsUserViewResponse, *http.Response, error)

	/*
		ListAccounts List Accounts

		List Accounts

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiListAccountsRequest
	*/
	ListAccounts(ctx context.Context, systemId string) ApiListAccountsRequest

	// ListAccountsExecute executes the request
	//  @return AccountListResponse
	ListAccountsExecute(r ApiListAccountsRequest) (*AccountListResponse, *http.Response, error)

	/*
		ListAccountsOverviewMetrics List Accounts overview metrics

		List Accounts overview metrics

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiListAccountsOverviewMetricsRequest
	*/
	ListAccountsOverviewMetrics(ctx context.Context, systemId string) ApiListAccountsOverviewMetricsRequest

	// ListAccountsOverviewMetricsExecute executes the request
	//  @return AccountsOverviewListResponse
	ListAccountsOverviewMetricsExecute(r ApiListAccountsOverviewMetricsRequest) (*AccountsOverviewListResponse, *http.Response, error)

	/*
		ListAgentTokens List Agent Tokens

		List Agent Tokens

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiListAgentTokensRequest
	*/
	ListAgentTokens(ctx context.Context, systemId string) ApiListAgentTokensRequest

	// ListAgentTokensExecute executes the request
	//  @return AgentTokenListResponse
	ListAgentTokensExecute(r ApiListAgentTokensRequest) (*AgentTokenListResponse, *http.Response, error)

	/*
		ListClusters List Clusters

		List cluster information

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiListClustersRequest
	*/
	ListClusters(ctx context.Context, systemId string) ApiListClustersRequest

	// ListClustersExecute executes the request
	//  @return NatsClusterListResponse
	ListClustersExecute(r ApiListClustersRequest) (*NatsClusterListResponse, *http.Response, error)

	/*
		ListConnections List Connections

		List Connections

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiListConnectionsRequest
	*/
	ListConnections(ctx context.Context, systemId string) ApiListConnectionsRequest

	// ListConnectionsExecute executes the request
	//  @return SystemConnectionsListResponse
	ListConnectionsExecute(r ApiListConnectionsRequest) (*SystemConnectionsListResponse, *http.Response, error)

	/*
		ListServers List Servers

		List server information

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiListServersRequest
	*/
	ListServers(ctx context.Context, systemId string) ApiListServersRequest

	// ListServersExecute executes the request
	//  @return NatsServerListResponse
	ListServersExecute(r ApiListServersRequest) (*NatsServerListResponse, *http.Response, error)

	/*
		ListSystemAlertRules List System Alert Rules

		List System Alert Rules

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiListSystemAlertRulesRequest
	*/
	ListSystemAlertRules(ctx context.Context, systemId string) ApiListSystemAlertRulesRequest

	// ListSystemAlertRulesExecute executes the request
	//  @return AlertRuleListResponse
	ListSystemAlertRulesExecute(r ApiListSystemAlertRulesRequest) (*AlertRuleListResponse, *http.Response, error)

	/*
		ListSystemInfoAccounts List System Accounts Info

		List info for Accounts within a System. Allows a user with access to a single account in a system to list info for all accounts in that system

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiListSystemInfoAccountsRequest
	*/
	ListSystemInfoAccounts(ctx context.Context, systemId string) ApiListSystemInfoAccountsRequest

	// ListSystemInfoAccountsExecute executes the request
	//  @return AccountSearchListResponse
	ListSystemInfoAccountsExecute(r ApiListSystemInfoAccountsRequest) (*AccountSearchListResponse, *http.Response, error)

	/*
		ListSystemInfoServers List System Servers info

		List info for NATS Servers within a System

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiListSystemInfoServersRequest
	*/
	ListSystemInfoServers(ctx context.Context, systemId string) ApiListSystemInfoServersRequest

	// ListSystemInfoServersExecute executes the request
	//  @return NatsServerInfoListResponse
	ListSystemInfoServersExecute(r ApiListSystemInfoServersRequest) (*NatsServerInfoListResponse, *http.Response, error)

	/*
		ListSystemTeamAppUsers List System Team App Users

		Returns a list of Team App Users associated with the System

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiListSystemTeamAppUsersRequest
	*/
	ListSystemTeamAppUsers(ctx context.Context, systemId string) ApiListSystemTeamAppUsersRequest

	// ListSystemTeamAppUsersExecute executes the request
	//  @return AppUserAssignListResponse
	ListSystemTeamAppUsersExecute(r ApiListSystemTeamAppUsersRequest) (*AppUserAssignListResponse, *http.Response, error)

	/*
		RotateAgentToken Rotate Agent Token

		Rotate token to connect a dataplane agent

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiRotateAgentTokenRequest
	*/
	RotateAgentToken(ctx context.Context, systemId string) ApiRotateAgentTokenRequest

	// RotateAgentTokenExecute executes the request
	//  @return AgentTokenRotateResponse
	RotateAgentTokenExecute(r ApiRotateAgentTokenRequest) (*AgentTokenRotateResponse, *http.Response, error)

	/*
		RunSystemAlertRule Run System Alert Rule

		Run System Alert Rule and return an alert object if the rule condition is met

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@param alertRuleId
		@return ApiRunSystemAlertRuleRequest
	*/
	RunSystemAlertRule(ctx context.Context, systemId string, alertRuleId string) ApiRunSystemAlertRuleRequest

	// RunSystemAlertRuleExecute executes the request
	//  @return AlertViewResponse
	RunSystemAlertRuleExecute(r ApiRunSystemAlertRuleRequest) (*AlertViewResponse, *http.Response, error)

	/*
			SystemJWTSync Re-sync JWTs of all accounts in this system

			Re-sync JWTs of all accounts in this system

		Use this endpoint to re-issue all JWTs. This endpoint just marks all account JWTs for renewal. The actual renewal takes place asynchronously and may take a while depending on the number of accounts.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param systemId
			@return ApiSystemJWTSyncRequest
	*/
	SystemJWTSync(ctx context.Context, systemId string) ApiSystemJWTSyncRequest

	// SystemJWTSyncExecute executes the request
	SystemJWTSyncExecute(r ApiSystemJWTSyncRequest) (*http.Response, error)

	/*
		UnAssignSystemTeamAppUser Unassign Team App User from System

		Unassign a Team App User from a System

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@param teamAppUserId
		@return ApiUnAssignSystemTeamAppUserRequest
	*/
	UnAssignSystemTeamAppUser(ctx context.Context, systemId string, teamAppUserId string) ApiUnAssignSystemTeamAppUserRequest

	// UnAssignSystemTeamAppUserExecute executes the request
	UnAssignSystemTeamAppUserExecute(r ApiUnAssignSystemTeamAppUserRequest) (*http.Response, error)

	/*
		UnmanageSystem Unmanage System

		Same as deleting a system but skips purging system and accounts from NATS

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@return ApiUnmanageSystemRequest
	*/
	UnmanageSystem(ctx context.Context, systemId string) ApiUnmanageSystemRequest

	// UnmanageSystemExecute executes the request
	UnmanageSystemExecute(r ApiUnmanageSystemRequest) (*http.Response, error)

	/*
			UpdateSystem Update System

			Updates a System

		To test the backend connection without updating the system, pass test_connection=true in query parameter.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param systemId
			@return ApiUpdateSystemRequest
	*/
	UpdateSystem(ctx context.Context, systemId string) ApiUpdateSystemRequest

	// UpdateSystemExecute executes the request
	//  @return SystemViewResponse
	UpdateSystemExecute(r ApiUpdateSystemRequest) (*SystemViewResponse, *http.Response, error)

	/*
		UpdateSystemAlertRule Update System Alert Rules

		Update System Alert Rules

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param systemId
		@param alertRuleId
		@return ApiUpdateSystemAlertRuleRequest
	*/
	UpdateSystemAlertRule(ctx context.Context, systemId string, alertRuleId string) ApiUpdateSystemAlertRuleRequest

	// UpdateSystemAlertRuleExecute executes the request
	//  @return AlertRuleViewResponse
	UpdateSystemAlertRuleExecute(r ApiUpdateSystemAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error)
}

// SystemAPIService SystemAPI service
type SystemAPIService service

type ApiAssignSystemTeamAppUserRequest struct {
	ctx                  context.Context
	ApiService           SystemAPI
	systemId             string
	teamAppUserId        string
	appUserAssignRequest *AppUserAssignRequest
}

func (r ApiAssignSystemTeamAppUserRequest) AppUserAssignRequest(appUserAssignRequest AppUserAssignRequest) ApiAssignSystemTeamAppUserRequest {
	r.appUserAssignRequest = &appUserAssignRequest
	return r
}

func (r ApiAssignSystemTeamAppUserRequest) Execute() (*AppUserAssignResponse, *http.Response, error) {
	return r.ApiService.AssignSystemTeamAppUserExecute(r)
}

/*
AssignSystemTeamAppUser Assign Team App User to System

Assign a Team App User to a System. This operation is idempotent; if an App User is already assigned to the System the assignment will be updated with the new role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@param teamAppUserId
	@return ApiAssignSystemTeamAppUserRequest
*/
func (a *SystemAPIService) AssignSystemTeamAppUser(ctx context.Context, systemId string, teamAppUserId string) ApiAssignSystemTeamAppUserRequest {
	return ApiAssignSystemTeamAppUserRequest{
		ApiService:    a,
		ctx:           ctx,
		systemId:      systemId,
		teamAppUserId: teamAppUserId,
	}
}

// Execute executes the request
//
//	@return AppUserAssignResponse
func (a *SystemAPIService) AssignSystemTeamAppUserExecute(r ApiAssignSystemTeamAppUserRequest) (*AppUserAssignResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppUserAssignResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.AssignSystemTeamAppUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/app-users/{teamAppUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamAppUserId"+"}", url.PathEscape(parameterValueToString(r.teamAppUserId, "teamAppUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appUserAssignRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountRequest struct {
	ctx                  context.Context
	ApiService           SystemAPI
	systemId             string
	accountCreateRequest *AccountCreateRequest
}

func (r ApiCreateAccountRequest) AccountCreateRequest(accountCreateRequest AccountCreateRequest) ApiCreateAccountRequest {
	r.accountCreateRequest = &accountCreateRequest
	return r
}

func (r ApiCreateAccountRequest) Execute() (*AccountViewResponse, *http.Response, error) {
	return r.ApiService.CreateAccountExecute(r)
}

/*
CreateAccount Create Account

Create Account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiCreateAccountRequest
*/
func (a *SystemAPIService) CreateAccount(ctx context.Context, systemId string) ApiCreateAccountRequest {
	return ApiCreateAccountRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return AccountViewResponse
func (a *SystemAPIService) CreateAccountExecute(r ApiCreateAccountRequest) (*AccountViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccountViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.CreateAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSystemAlertRuleRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
	body       *AlertRuleBaseCreateRequest
}

func (r ApiCreateSystemAlertRuleRequest) Body(body AlertRuleBaseCreateRequest) ApiCreateSystemAlertRuleRequest {
	r.body = &body
	return r
}

func (r ApiCreateSystemAlertRuleRequest) Execute() (*AlertRuleViewResponse, *http.Response, error) {
	return r.ApiService.CreateSystemAlertRuleExecute(r)
}

/*
CreateSystemAlertRule Create System Alert Rule

Create System Alert Rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiCreateSystemAlertRuleRequest
*/
func (a *SystemAPIService) CreateSystemAlertRule(ctx context.Context, systemId string) ApiCreateSystemAlertRuleRequest {
	return ApiCreateSystemAlertRuleRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return AlertRuleViewResponse
func (a *SystemAPIService) CreateSystemAlertRuleExecute(r ApiCreateSystemAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRuleViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.CreateSystemAlertRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/alert-rules"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSystemRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiDeleteSystemRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSystemExecute(r)
}

/*
DeleteSystem Delete System

Deletes System

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiDeleteSystemRequest
*/
func (a *SystemAPIService) DeleteSystem(ctx context.Context, systemId string) ApiDeleteSystemRequest {
	return ApiDeleteSystemRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
func (a *SystemAPIService) DeleteSystemExecute(r ApiDeleteSystemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.DeleteSystem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSystemAlertRuleRequest struct {
	ctx         context.Context
	ApiService  SystemAPI
	systemId    string
	alertRuleId string
}

func (r ApiDeleteSystemAlertRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSystemAlertRuleExecute(r)
}

/*
DeleteSystemAlertRule Delete System Alert Rule

Delete System Alert rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@param alertRuleId
	@return ApiDeleteSystemAlertRuleRequest
*/
func (a *SystemAPIService) DeleteSystemAlertRule(ctx context.Context, systemId string, alertRuleId string) ApiDeleteSystemAlertRuleRequest {
	return ApiDeleteSystemAlertRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		systemId:    systemId,
		alertRuleId: alertRuleId,
	}
}

// Execute executes the request
func (a *SystemAPIService) DeleteSystemAlertRuleExecute(r ApiDeleteSystemAlertRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.DeleteSystemAlertRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/alert-rules/{alertRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertRuleId"+"}", url.PathEscape(parameterValueToString(r.alertRuleId, "alertRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadSystemLogsRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiDownloadSystemLogsRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadSystemLogsExecute(r)
}

/*
DownloadSystemLogs Download Logs

Download System Logs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiDownloadSystemLogsRequest
*/
func (a *SystemAPIService) DownloadSystemLogs(ctx context.Context, systemId string) ApiDownloadSystemLogsRequest {
	return ApiDownloadSystemLogsRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return *os.File
func (a *SystemAPIService) DownloadSystemLogsExecute(r ApiDownloadSystemLogsRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.DownloadSystemLogs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/logs"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/gzip"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCurrentAgentTokenRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiGetCurrentAgentTokenRequest) Execute() (*AgentTokenCurrentResponse, *http.Response, error) {
	return r.ApiService.GetCurrentAgentTokenExecute(r)
}

/*
GetCurrentAgentToken Get Current Agent Token

Get the Current Agent Token

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiGetCurrentAgentTokenRequest
*/
func (a *SystemAPIService) GetCurrentAgentToken(ctx context.Context, systemId string) ApiGetCurrentAgentTokenRequest {
	return ApiGetCurrentAgentTokenRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return AgentTokenCurrentResponse
func (a *SystemAPIService) GetCurrentAgentTokenExecute(r ApiGetCurrentAgentTokenRequest) (*AgentTokenCurrentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentTokenCurrentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.GetCurrentAgentToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/agent-tokens/current"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSystemRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiGetSystemRequest) Execute() (*SystemViewResponse, *http.Response, error) {
	return r.ApiService.GetSystemExecute(r)
}

/*
GetSystem Get System

Returns a System by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiGetSystemRequest
*/
func (a *SystemAPIService) GetSystem(ctx context.Context, systemId string) ApiGetSystemRequest {
	return ApiGetSystemRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return SystemViewResponse
func (a *SystemAPIService) GetSystemExecute(r ApiGetSystemRequest) (*SystemViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SystemViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.GetSystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSystemAlertRuleRequest struct {
	ctx         context.Context
	ApiService  SystemAPI
	systemId    string
	alertRuleId string
}

func (r ApiGetSystemAlertRuleRequest) Execute() (*AlertRuleViewResponse, *http.Response, error) {
	return r.ApiService.GetSystemAlertRuleExecute(r)
}

/*
GetSystemAlertRule Get System Alert Rule

Get System Alert Rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@param alertRuleId
	@return ApiGetSystemAlertRuleRequest
*/
func (a *SystemAPIService) GetSystemAlertRule(ctx context.Context, systemId string, alertRuleId string) ApiGetSystemAlertRuleRequest {
	return ApiGetSystemAlertRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		systemId:    systemId,
		alertRuleId: alertRuleId,
	}
}

// Execute executes the request
//
//	@return AlertRuleViewResponse
func (a *SystemAPIService) GetSystemAlertRuleExecute(r ApiGetSystemAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRuleViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.GetSystemAlertRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/alert-rules/{alertRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertRuleId"+"}", url.PathEscape(parameterValueToString(r.alertRuleId, "alertRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSystemLimitsRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiGetSystemLimitsRequest) Execute() (*SystemLimitsResponse, *http.Response, error) {
	return r.ApiService.GetSystemLimitsExecute(r)
}

/*
GetSystemLimits Get System Limits

Get system total and allocated limits

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiGetSystemLimitsRequest
*/
func (a *SystemAPIService) GetSystemLimits(ctx context.Context, systemId string) ApiGetSystemLimitsRequest {
	return ApiGetSystemLimitsRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return SystemLimitsResponse
func (a *SystemAPIService) GetSystemLimitsExecute(r ApiGetSystemLimitsRequest) (*SystemLimitsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SystemLimitsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.GetSystemLimits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/limits"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportAccountRequest struct {
	ctx                        context.Context
	ApiService                 SystemAPI
	systemId                   string
	systemAccountImportRequest *SystemAccountImportRequest
}

func (r ApiImportAccountRequest) SystemAccountImportRequest(systemAccountImportRequest SystemAccountImportRequest) ApiImportAccountRequest {
	r.systemAccountImportRequest = &systemAccountImportRequest
	return r
}

func (r ApiImportAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.ImportAccountExecute(r)
}

/*
ImportAccount Import Account

Imports an existing account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiImportAccountRequest
*/
func (a *SystemAPIService) ImportAccount(ctx context.Context, systemId string) ApiImportAccountRequest {
	return ApiImportAccountRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
func (a *SystemAPIService) ImportAccountExecute(r ApiImportAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ImportAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/import-account"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.systemAccountImportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiImportUserRequest struct {
	ctx                     context.Context
	ApiService              SystemAPI
	systemId                string
	systemUserImportRequest *SystemUserImportRequest
}

func (r ApiImportUserRequest) SystemUserImportRequest(systemUserImportRequest SystemUserImportRequest) ApiImportUserRequest {
	r.systemUserImportRequest = &systemUserImportRequest
	return r
}

func (r ApiImportUserRequest) Execute() (*NatsUserViewResponse, *http.Response, error) {
	return r.ApiService.ImportUserExecute(r)
}

/*
ImportUser Import User

Imports an existing NATS user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiImportUserRequest
*/
func (a *SystemAPIService) ImportUser(ctx context.Context, systemId string) ApiImportUserRequest {
	return ApiImportUserRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return NatsUserViewResponse
func (a *SystemAPIService) ImportUserExecute(r ApiImportUserRequest) (*NatsUserViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ImportUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/import-user"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.systemUserImportRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAccountsRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiListAccountsRequest) Execute() (*AccountListResponse, *http.Response, error) {
	return r.ApiService.ListAccountsExecute(r)
}

/*
ListAccounts List Accounts

List Accounts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiListAccountsRequest
*/
func (a *SystemAPIService) ListAccounts(ctx context.Context, systemId string) ApiListAccountsRequest {
	return ApiListAccountsRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return AccountListResponse
func (a *SystemAPIService) ListAccountsExecute(r ApiListAccountsRequest) (*AccountListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccountListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ListAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAccountsOverviewMetricsRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiListAccountsOverviewMetricsRequest) Execute() (*AccountsOverviewListResponse, *http.Response, error) {
	return r.ApiService.ListAccountsOverviewMetricsExecute(r)
}

/*
ListAccountsOverviewMetrics List Accounts overview metrics

List Accounts overview metrics

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiListAccountsOverviewMetricsRequest
*/
func (a *SystemAPIService) ListAccountsOverviewMetrics(ctx context.Context, systemId string) ApiListAccountsOverviewMetricsRequest {
	return ApiListAccountsOverviewMetricsRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return AccountsOverviewListResponse
func (a *SystemAPIService) ListAccountsOverviewMetricsExecute(r ApiListAccountsOverviewMetricsRequest) (*AccountsOverviewListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccountsOverviewListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ListAccountsOverviewMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/accounts-overview-metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAgentTokensRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiListAgentTokensRequest) Execute() (*AgentTokenListResponse, *http.Response, error) {
	return r.ApiService.ListAgentTokensExecute(r)
}

/*
ListAgentTokens List Agent Tokens

List Agent Tokens

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiListAgentTokensRequest
*/
func (a *SystemAPIService) ListAgentTokens(ctx context.Context, systemId string) ApiListAgentTokensRequest {
	return ApiListAgentTokensRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return AgentTokenListResponse
func (a *SystemAPIService) ListAgentTokensExecute(r ApiListAgentTokensRequest) (*AgentTokenListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentTokenListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ListAgentTokens")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/agent-tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListClustersRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiListClustersRequest) Execute() (*NatsClusterListResponse, *http.Response, error) {
	return r.ApiService.ListClustersExecute(r)
}

/*
ListClusters List Clusters

List cluster information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiListClustersRequest
*/
func (a *SystemAPIService) ListClusters(ctx context.Context, systemId string) ApiListClustersRequest {
	return ApiListClustersRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return NatsClusterListResponse
func (a *SystemAPIService) ListClustersExecute(r ApiListClustersRequest) (*NatsClusterListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsClusterListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ListClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/nats-clusters"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListConnectionsRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
	sort       *string
	account    *string
	cid        *string
	state      *string
	subject    *string
	limit      *float32
	user       *string
}

func (r ApiListConnectionsRequest) Sort(sort string) ApiListConnectionsRequest {
	r.sort = &sort
	return r
}

func (r ApiListConnectionsRequest) Account(account string) ApiListConnectionsRequest {
	r.account = &account
	return r
}

func (r ApiListConnectionsRequest) Cid(cid string) ApiListConnectionsRequest {
	r.cid = &cid
	return r
}

func (r ApiListConnectionsRequest) State(state string) ApiListConnectionsRequest {
	r.state = &state
	return r
}

func (r ApiListConnectionsRequest) Subject(subject string) ApiListConnectionsRequest {
	r.subject = &subject
	return r
}

func (r ApiListConnectionsRequest) Limit(limit float32) ApiListConnectionsRequest {
	r.limit = &limit
	return r
}

func (r ApiListConnectionsRequest) User(user string) ApiListConnectionsRequest {
	r.user = &user
	return r
}

func (r ApiListConnectionsRequest) Execute() (*SystemConnectionsListResponse, *http.Response, error) {
	return r.ApiService.ListConnectionsExecute(r)
}

/*
ListConnections List Connections

List Connections

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiListConnectionsRequest
*/
func (a *SystemAPIService) ListConnections(ctx context.Context, systemId string) ApiListConnectionsRequest {
	return ApiListConnectionsRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return SystemConnectionsListResponse
func (a *SystemAPIService) ListConnectionsExecute(r ApiListConnectionsRequest) (*SystemConnectionsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SystemConnectionsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ListConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/connections"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "")
	}
	if r.cid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cid", r.cid, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.subject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subject", r.subject, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListServersRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiListServersRequest) Execute() (*NatsServerListResponse, *http.Response, error) {
	return r.ApiService.ListServersExecute(r)
}

/*
ListServers List Servers

List server information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiListServersRequest
*/
func (a *SystemAPIService) ListServers(ctx context.Context, systemId string) ApiListServersRequest {
	return ApiListServersRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return NatsServerListResponse
func (a *SystemAPIService) ListServersExecute(r ApiListServersRequest) (*NatsServerListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsServerListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ListServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/servers"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSystemAlertRulesRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiListSystemAlertRulesRequest) Execute() (*AlertRuleListResponse, *http.Response, error) {
	return r.ApiService.ListSystemAlertRulesExecute(r)
}

/*
ListSystemAlertRules List System Alert Rules

List System Alert Rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiListSystemAlertRulesRequest
*/
func (a *SystemAPIService) ListSystemAlertRules(ctx context.Context, systemId string) ApiListSystemAlertRulesRequest {
	return ApiListSystemAlertRulesRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return AlertRuleListResponse
func (a *SystemAPIService) ListSystemAlertRulesExecute(r ApiListSystemAlertRulesRequest) (*AlertRuleListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRuleListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ListSystemAlertRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/alert-rules"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSystemInfoAccountsRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiListSystemInfoAccountsRequest) Execute() (*AccountSearchListResponse, *http.Response, error) {
	return r.ApiService.ListSystemInfoAccountsExecute(r)
}

/*
ListSystemInfoAccounts List System Accounts Info

List info for Accounts within a System. Allows a user with access to a single account in a system to list info for all accounts in that system

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiListSystemInfoAccountsRequest
*/
func (a *SystemAPIService) ListSystemInfoAccounts(ctx context.Context, systemId string) ApiListSystemInfoAccountsRequest {
	return ApiListSystemInfoAccountsRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return AccountSearchListResponse
func (a *SystemAPIService) ListSystemInfoAccountsExecute(r ApiListSystemInfoAccountsRequest) (*AccountSearchListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccountSearchListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ListSystemInfoAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/info/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSystemInfoServersRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiListSystemInfoServersRequest) Execute() (*NatsServerInfoListResponse, *http.Response, error) {
	return r.ApiService.ListSystemInfoServersExecute(r)
}

/*
ListSystemInfoServers List System Servers info

List info for NATS Servers within a System

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiListSystemInfoServersRequest
*/
func (a *SystemAPIService) ListSystemInfoServers(ctx context.Context, systemId string) ApiListSystemInfoServersRequest {
	return ApiListSystemInfoServersRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return NatsServerInfoListResponse
func (a *SystemAPIService) ListSystemInfoServersExecute(r ApiListSystemInfoServersRequest) (*NatsServerInfoListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsServerInfoListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ListSystemInfoServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/info/servers"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSystemTeamAppUsersRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiListSystemTeamAppUsersRequest) Execute() (*AppUserAssignListResponse, *http.Response, error) {
	return r.ApiService.ListSystemTeamAppUsersExecute(r)
}

/*
ListSystemTeamAppUsers List System Team App Users

Returns a list of Team App Users associated with the System

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiListSystemTeamAppUsersRequest
*/
func (a *SystemAPIService) ListSystemTeamAppUsers(ctx context.Context, systemId string) ApiListSystemTeamAppUsersRequest {
	return ApiListSystemTeamAppUsersRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return AppUserAssignListResponse
func (a *SystemAPIService) ListSystemTeamAppUsersExecute(r ApiListSystemTeamAppUsersRequest) (*AppUserAssignListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppUserAssignListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.ListSystemTeamAppUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/app-users"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotateAgentTokenRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
	body       *map[string]interface{}
}

func (r ApiRotateAgentTokenRequest) Body(body map[string]interface{}) ApiRotateAgentTokenRequest {
	r.body = &body
	return r
}

func (r ApiRotateAgentTokenRequest) Execute() (*AgentTokenRotateResponse, *http.Response, error) {
	return r.ApiService.RotateAgentTokenExecute(r)
}

/*
RotateAgentToken Rotate Agent Token

Rotate token to connect a dataplane agent

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiRotateAgentTokenRequest
*/
func (a *SystemAPIService) RotateAgentToken(ctx context.Context, systemId string) ApiRotateAgentTokenRequest {
	return ApiRotateAgentTokenRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return AgentTokenRotateResponse
func (a *SystemAPIService) RotateAgentTokenExecute(r ApiRotateAgentTokenRequest) (*AgentTokenRotateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AgentTokenRotateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.RotateAgentToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/agent-tokens"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunSystemAlertRuleRequest struct {
	ctx         context.Context
	ApiService  SystemAPI
	systemId    string
	alertRuleId string
}

func (r ApiRunSystemAlertRuleRequest) Execute() (*AlertViewResponse, *http.Response, error) {
	return r.ApiService.RunSystemAlertRuleExecute(r)
}

/*
RunSystemAlertRule Run System Alert Rule

Run System Alert Rule and return an alert object if the rule condition is met

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@param alertRuleId
	@return ApiRunSystemAlertRuleRequest
*/
func (a *SystemAPIService) RunSystemAlertRule(ctx context.Context, systemId string, alertRuleId string) ApiRunSystemAlertRuleRequest {
	return ApiRunSystemAlertRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		systemId:    systemId,
		alertRuleId: alertRuleId,
	}
}

// Execute executes the request
//
//	@return AlertViewResponse
func (a *SystemAPIService) RunSystemAlertRuleExecute(r ApiRunSystemAlertRuleRequest) (*AlertViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.RunSystemAlertRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/alert-rules/{alertRuleId}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertRuleId"+"}", url.PathEscape(parameterValueToString(r.alertRuleId, "alertRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSystemJWTSyncRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiSystemJWTSyncRequest) Execute() (*http.Response, error) {
	return r.ApiService.SystemJWTSyncExecute(r)
}

/*
SystemJWTSync Re-sync JWTs of all accounts in this system

# Re-sync JWTs of all accounts in this system

Use this endpoint to re-issue all JWTs. This endpoint just marks all account JWTs for renewal. The actual renewal takes place asynchronously and may take a while depending on the number of accounts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiSystemJWTSyncRequest
*/
func (a *SystemAPIService) SystemJWTSync(ctx context.Context, systemId string) ApiSystemJWTSyncRequest {
	return ApiSystemJWTSyncRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
func (a *SystemAPIService) SystemJWTSyncExecute(r ApiSystemJWTSyncRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.SystemJWTSync")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/jwt-sync"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnAssignSystemTeamAppUserRequest struct {
	ctx           context.Context
	ApiService    SystemAPI
	systemId      string
	teamAppUserId string
}

func (r ApiUnAssignSystemTeamAppUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnAssignSystemTeamAppUserExecute(r)
}

/*
UnAssignSystemTeamAppUser Unassign Team App User from System

Unassign a Team App User from a System

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@param teamAppUserId
	@return ApiUnAssignSystemTeamAppUserRequest
*/
func (a *SystemAPIService) UnAssignSystemTeamAppUser(ctx context.Context, systemId string, teamAppUserId string) ApiUnAssignSystemTeamAppUserRequest {
	return ApiUnAssignSystemTeamAppUserRequest{
		ApiService:    a,
		ctx:           ctx,
		systemId:      systemId,
		teamAppUserId: teamAppUserId,
	}
}

// Execute executes the request
func (a *SystemAPIService) UnAssignSystemTeamAppUserExecute(r ApiUnAssignSystemTeamAppUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.UnAssignSystemTeamAppUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/app-users/{teamAppUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamAppUserId"+"}", url.PathEscape(parameterValueToString(r.teamAppUserId, "teamAppUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnmanageSystemRequest struct {
	ctx        context.Context
	ApiService SystemAPI
	systemId   string
}

func (r ApiUnmanageSystemRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnmanageSystemExecute(r)
}

/*
UnmanageSystem Unmanage System

Same as deleting a system but skips purging system and accounts from NATS

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiUnmanageSystemRequest
*/
func (a *SystemAPIService) UnmanageSystem(ctx context.Context, systemId string) ApiUnmanageSystemRequest {
	return ApiUnmanageSystemRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
func (a *SystemAPIService) UnmanageSystemExecute(r ApiUnmanageSystemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.UnmanageSystem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/unmanage"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSystemRequest struct {
	ctx                 context.Context
	ApiService          SystemAPI
	systemId            string
	testConnection      *bool
	systemUpdateRequest *SystemUpdateRequest
}

func (r ApiUpdateSystemRequest) TestConnection(testConnection bool) ApiUpdateSystemRequest {
	r.testConnection = &testConnection
	return r
}

func (r ApiUpdateSystemRequest) SystemUpdateRequest(systemUpdateRequest SystemUpdateRequest) ApiUpdateSystemRequest {
	r.systemUpdateRequest = &systemUpdateRequest
	return r
}

func (r ApiUpdateSystemRequest) Execute() (*SystemViewResponse, *http.Response, error) {
	return r.ApiService.UpdateSystemExecute(r)
}

/*
UpdateSystem Update System

# Updates a System

To test the backend connection without updating the system, pass test_connection=true in query parameter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@return ApiUpdateSystemRequest
*/
func (a *SystemAPIService) UpdateSystem(ctx context.Context, systemId string) ApiUpdateSystemRequest {
	return ApiUpdateSystemRequest{
		ApiService: a,
		ctx:        ctx,
		systemId:   systemId,
	}
}

// Execute executes the request
//
//	@return SystemViewResponse
func (a *SystemAPIService) UpdateSystemExecute(r ApiUpdateSystemRequest) (*SystemViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SystemViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.UpdateSystem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.testConnection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "test_connection", r.testConnection, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.systemUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSystemAlertRuleRequest struct {
	ctx                    context.Context
	ApiService             SystemAPI
	systemId               string
	alertRuleId            string
	alertRuleUpdateRequest *AlertRuleUpdateRequest
}

func (r ApiUpdateSystemAlertRuleRequest) AlertRuleUpdateRequest(alertRuleUpdateRequest AlertRuleUpdateRequest) ApiUpdateSystemAlertRuleRequest {
	r.alertRuleUpdateRequest = &alertRuleUpdateRequest
	return r
}

func (r ApiUpdateSystemAlertRuleRequest) Execute() (*AlertRuleViewResponse, *http.Response, error) {
	return r.ApiService.UpdateSystemAlertRuleExecute(r)
}

/*
UpdateSystemAlertRule Update System Alert Rules

Update System Alert Rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param systemId
	@param alertRuleId
	@return ApiUpdateSystemAlertRuleRequest
*/
func (a *SystemAPIService) UpdateSystemAlertRule(ctx context.Context, systemId string, alertRuleId string) ApiUpdateSystemAlertRuleRequest {
	return ApiUpdateSystemAlertRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		systemId:    systemId,
		alertRuleId: alertRuleId,
	}
}

// Execute executes the request
//
//	@return AlertRuleViewResponse
func (a *SystemAPIService) UpdateSystemAlertRuleExecute(r ApiUpdateSystemAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRuleViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SystemAPIService.UpdateSystemAlertRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/systems/{systemId}/alert-rules/{alertRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"systemId"+"}", url.PathEscape(parameterValueToString(r.systemId, "systemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertRuleId"+"}", url.PathEscape(parameterValueToString(r.alertRuleId, "alertRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alertRuleUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
