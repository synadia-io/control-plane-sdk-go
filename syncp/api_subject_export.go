/*
Synadia Control Plane

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package syncp

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type SubjectExportAPI interface {

	/*
		CreateSubjectShares Create Subject Shares

		Creates Subject Shares

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param subjectExportId
		@return ApiCreateSubjectSharesRequest
	*/
	CreateSubjectShares(ctx context.Context, subjectExportId string) ApiCreateSubjectSharesRequest

	// CreateSubjectSharesExecute executes the request
	//  @return SubjectShareViewResponse
	CreateSubjectSharesExecute(r ApiCreateSubjectSharesRequest) (*SubjectShareViewResponse, *http.Response, error)

	/*
		DeleteSubjectExport Delete Subject Export

		Delete Subject Export

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param subjectExportId
		@return ApiDeleteSubjectExportRequest
	*/
	DeleteSubjectExport(ctx context.Context, subjectExportId string) ApiDeleteSubjectExportRequest

	// DeleteSubjectExportExecute executes the request
	DeleteSubjectExportExecute(r ApiDeleteSubjectExportRequest) (*http.Response, error)

	/*
		DeleteSubjectShare Delete Subject Share

		Revokes the share for account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param subjectExportId
		@param targetAccountNKeyPublic
		@return ApiDeleteSubjectShareRequest
	*/
	DeleteSubjectShare(ctx context.Context, subjectExportId string, targetAccountNKeyPublic string) ApiDeleteSubjectShareRequest

	// DeleteSubjectShareExecute executes the request
	DeleteSubjectShareExecute(r ApiDeleteSubjectShareRequest) (*http.Response, error)

	/*
		GetSubjectExport Get Subject Export

		Returns Subject Export info

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param subjectExportId
		@return ApiGetSubjectExportRequest
	*/
	GetSubjectExport(ctx context.Context, subjectExportId string) ApiGetSubjectExportRequest

	// GetSubjectExportExecute executes the request
	//  @return SubjectExportViewResponse
	GetSubjectExportExecute(r ApiGetSubjectExportRequest) (*SubjectExportViewResponse, *http.Response, error)

	/*
		ListSubjectShares List Subject Shares

		List subject shares for this export

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param subjectExportId
		@return ApiListSubjectSharesRequest
	*/
	ListSubjectShares(ctx context.Context, subjectExportId string) ApiListSubjectSharesRequest

	// ListSubjectSharesExecute executes the request
	//  @return SubjectShareListResponse
	ListSubjectSharesExecute(r ApiListSubjectSharesRequest) (*SubjectShareListResponse, *http.Response, error)

	/*
		UpdateSubjectExport Update Subject Export

		Update Subject Export

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param subjectExportId
		@return ApiUpdateSubjectExportRequest
	*/
	UpdateSubjectExport(ctx context.Context, subjectExportId string) ApiUpdateSubjectExportRequest

	// UpdateSubjectExportExecute executes the request
	//  @return SubjectExportViewResponse
	UpdateSubjectExportExecute(r ApiUpdateSubjectExportRequest) (*SubjectExportViewResponse, *http.Response, error)
}

// SubjectExportAPIService SubjectExportAPI service
type SubjectExportAPIService service

type ApiCreateSubjectSharesRequest struct {
	ctx                       context.Context
	ApiService                SubjectExportAPI
	subjectExportId           string
	subjectShareCreateRequest *SubjectShareCreateRequest
}

func (r ApiCreateSubjectSharesRequest) SubjectShareCreateRequest(subjectShareCreateRequest SubjectShareCreateRequest) ApiCreateSubjectSharesRequest {
	r.subjectShareCreateRequest = &subjectShareCreateRequest
	return r
}

func (r ApiCreateSubjectSharesRequest) Execute() (*SubjectShareViewResponse, *http.Response, error) {
	return r.ApiService.CreateSubjectSharesExecute(r)
}

/*
CreateSubjectShares Create Subject Shares

Creates Subject Shares

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subjectExportId
	@return ApiCreateSubjectSharesRequest
*/
func (a *SubjectExportAPIService) CreateSubjectShares(ctx context.Context, subjectExportId string) ApiCreateSubjectSharesRequest {
	return ApiCreateSubjectSharesRequest{
		ApiService:      a,
		ctx:             ctx,
		subjectExportId: subjectExportId,
	}
}

// Execute executes the request
//
//	@return SubjectShareViewResponse
func (a *SubjectExportAPIService) CreateSubjectSharesExecute(r ApiCreateSubjectSharesRequest) (*SubjectShareViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubjectShareViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubjectExportAPIService.CreateSubjectShares")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subject-exports/{subjectExportId}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"subjectExportId"+"}", url.PathEscape(parameterValueToString(r.subjectExportId, "subjectExportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subjectShareCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSubjectExportRequest struct {
	ctx             context.Context
	ApiService      SubjectExportAPI
	subjectExportId string
}

func (r ApiDeleteSubjectExportRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSubjectExportExecute(r)
}

/*
DeleteSubjectExport Delete Subject Export

Delete Subject Export

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subjectExportId
	@return ApiDeleteSubjectExportRequest
*/
func (a *SubjectExportAPIService) DeleteSubjectExport(ctx context.Context, subjectExportId string) ApiDeleteSubjectExportRequest {
	return ApiDeleteSubjectExportRequest{
		ApiService:      a,
		ctx:             ctx,
		subjectExportId: subjectExportId,
	}
}

// Execute executes the request
func (a *SubjectExportAPIService) DeleteSubjectExportExecute(r ApiDeleteSubjectExportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubjectExportAPIService.DeleteSubjectExport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subject-exports/{subjectExportId}"
	localVarPath = strings.Replace(localVarPath, "{"+"subjectExportId"+"}", url.PathEscape(parameterValueToString(r.subjectExportId, "subjectExportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSubjectShareRequest struct {
	ctx                     context.Context
	ApiService              SubjectExportAPI
	subjectExportId         string
	targetAccountNKeyPublic string
}

func (r ApiDeleteSubjectShareRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSubjectShareExecute(r)
}

/*
DeleteSubjectShare Delete Subject Share

Revokes the share for account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subjectExportId
	@param targetAccountNKeyPublic
	@return ApiDeleteSubjectShareRequest
*/
func (a *SubjectExportAPIService) DeleteSubjectShare(ctx context.Context, subjectExportId string, targetAccountNKeyPublic string) ApiDeleteSubjectShareRequest {
	return ApiDeleteSubjectShareRequest{
		ApiService:              a,
		ctx:                     ctx,
		subjectExportId:         subjectExportId,
		targetAccountNKeyPublic: targetAccountNKeyPublic,
	}
}

// Execute executes the request
func (a *SubjectExportAPIService) DeleteSubjectShareExecute(r ApiDeleteSubjectShareRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubjectExportAPIService.DeleteSubjectShare")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subject-exports/{subjectExportId}/shares/{targetAccountNKeyPublic}"
	localVarPath = strings.Replace(localVarPath, "{"+"subjectExportId"+"}", url.PathEscape(parameterValueToString(r.subjectExportId, "subjectExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"targetAccountNKeyPublic"+"}", url.PathEscape(parameterValueToString(r.targetAccountNKeyPublic, "targetAccountNKeyPublic")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetSubjectExportRequest struct {
	ctx             context.Context
	ApiService      SubjectExportAPI
	subjectExportId string
}

func (r ApiGetSubjectExportRequest) Execute() (*SubjectExportViewResponse, *http.Response, error) {
	return r.ApiService.GetSubjectExportExecute(r)
}

/*
GetSubjectExport Get Subject Export

Returns Subject Export info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subjectExportId
	@return ApiGetSubjectExportRequest
*/
func (a *SubjectExportAPIService) GetSubjectExport(ctx context.Context, subjectExportId string) ApiGetSubjectExportRequest {
	return ApiGetSubjectExportRequest{
		ApiService:      a,
		ctx:             ctx,
		subjectExportId: subjectExportId,
	}
}

// Execute executes the request
//
//	@return SubjectExportViewResponse
func (a *SubjectExportAPIService) GetSubjectExportExecute(r ApiGetSubjectExportRequest) (*SubjectExportViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubjectExportViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubjectExportAPIService.GetSubjectExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subject-exports/{subjectExportId}"
	localVarPath = strings.Replace(localVarPath, "{"+"subjectExportId"+"}", url.PathEscape(parameterValueToString(r.subjectExportId, "subjectExportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSubjectSharesRequest struct {
	ctx             context.Context
	ApiService      SubjectExportAPI
	subjectExportId string
}

func (r ApiListSubjectSharesRequest) Execute() (*SubjectShareListResponse, *http.Response, error) {
	return r.ApiService.ListSubjectSharesExecute(r)
}

/*
ListSubjectShares List Subject Shares

List subject shares for this export

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subjectExportId
	@return ApiListSubjectSharesRequest
*/
func (a *SubjectExportAPIService) ListSubjectShares(ctx context.Context, subjectExportId string) ApiListSubjectSharesRequest {
	return ApiListSubjectSharesRequest{
		ApiService:      a,
		ctx:             ctx,
		subjectExportId: subjectExportId,
	}
}

// Execute executes the request
//
//	@return SubjectShareListResponse
func (a *SubjectExportAPIService) ListSubjectSharesExecute(r ApiListSubjectSharesRequest) (*SubjectShareListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubjectShareListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubjectExportAPIService.ListSubjectShares")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subject-exports/{subjectExportId}/shares"
	localVarPath = strings.Replace(localVarPath, "{"+"subjectExportId"+"}", url.PathEscape(parameterValueToString(r.subjectExportId, "subjectExportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSubjectExportRequest struct {
	ctx                        context.Context
	ApiService                 SubjectExportAPI
	subjectExportId            string
	subjectExportUpdateRequest *SubjectExportUpdateRequest
}

func (r ApiUpdateSubjectExportRequest) SubjectExportUpdateRequest(subjectExportUpdateRequest SubjectExportUpdateRequest) ApiUpdateSubjectExportRequest {
	r.subjectExportUpdateRequest = &subjectExportUpdateRequest
	return r
}

func (r ApiUpdateSubjectExportRequest) Execute() (*SubjectExportViewResponse, *http.Response, error) {
	return r.ApiService.UpdateSubjectExportExecute(r)
}

/*
UpdateSubjectExport Update Subject Export

Update Subject Export

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param subjectExportId
	@return ApiUpdateSubjectExportRequest
*/
func (a *SubjectExportAPIService) UpdateSubjectExport(ctx context.Context, subjectExportId string) ApiUpdateSubjectExportRequest {
	return ApiUpdateSubjectExportRequest{
		ApiService:      a,
		ctx:             ctx,
		subjectExportId: subjectExportId,
	}
}

// Execute executes the request
//
//	@return SubjectExportViewResponse
func (a *SubjectExportAPIService) UpdateSubjectExportExecute(r ApiUpdateSubjectExportRequest) (*SubjectExportViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubjectExportViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubjectExportAPIService.UpdateSubjectExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/subject-exports/{subjectExportId}"
	localVarPath = strings.Replace(localVarPath, "{"+"subjectExportId"+"}", url.PathEscape(parameterValueToString(r.subjectExportId, "subjectExportId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subjectExportUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
