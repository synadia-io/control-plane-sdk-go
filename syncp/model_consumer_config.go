/*
Synadia Control Plane

API for Synadia Control Plane Server

API version: beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package syncp

// checks if the ConsumerConfig type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &ConsumerConfig{}

// ConsumerConfig ConsumerConfig is the configuration for a JetStream consumes  NATS Schema Type io.nats.jetstream.api.v1.consumer_configuration
type ConsumerConfig struct {
	AckPolicy      AckPolicy     `json:"ack_policy"`
	AckWait        *int64        `json:"ack_wait,omitempty"`
	Backoff        []int64       `json:"backoff,omitempty"`
	DeliverGroup   *string       `json:"deliver_group,omitempty"`
	DeliverPolicy  DeliverPolicy `json:"deliver_policy"`
	DeliverSubject *string       `json:"deliver_subject,omitempty"`
	Description    *string       `json:"description,omitempty"`
	// Don't add to general clients.
	Direct            *bool    `json:"direct,omitempty"`
	DurableName       *string  `json:"durable_name,omitempty"`
	FilterSubject     *string  `json:"filter_subject,omitempty"`
	FilterSubjects    []string `json:"filter_subjects,omitempty"`
	FlowControl       *bool    `json:"flow_control,omitempty"`
	HeadersOnly       *bool    `json:"headers_only,omitempty"`
	IdleHeartbeat     *int64   `json:"idle_heartbeat,omitempty"`
	InactiveThreshold *int64   `json:"inactive_threshold,omitempty"`
	MaxAckPending     *int32   `json:"max_ack_pending,omitempty"`
	MaxBatch          *int32   `json:"max_batch,omitempty"`
	MaxBytes          *int32   `json:"max_bytes,omitempty"`
	MaxDeliver        *int32   `json:"max_deliver,omitempty"`
	MaxExpires        *int64   `json:"max_expires,omitempty"`
	MaxWaiting        *int32   `json:"max_waiting,omitempty"`
	MemStorage        *bool    `json:"mem_storage,omitempty"`
	// Metadata is additional metadata for the Consumer.
	Metadata     map[string]string `json:"metadata,omitempty"`
	Name         *string           `json:"name,omitempty"`
	NumReplicas  int32             `json:"num_replicas"`
	OptStartSeq  *int32            `json:"opt_start_seq,omitempty"`
	OptStartTime *Nullable[string] `json:"opt_start_time,omitempty"`
	RateLimitBps *int32            `json:"rate_limit_bps,omitempty"`
	ReplayPolicy ReplayPolicy      `json:"replay_policy"`
	SampleFreq   *string           `json:"sample_freq,omitempty"`
}

func (o ConsumerConfig) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["ack_policy"] = o.AckPolicy
	if o.AckWait != nil {
		toSerialize["ack_wait"] = o.AckWait
	}
	if len(o.Backoff) != 0 {
		toSerialize["backoff"] = o.Backoff
	}
	if o.DeliverGroup != nil {
		toSerialize["deliver_group"] = o.DeliverGroup
	}
	toSerialize["deliver_policy"] = o.DeliverPolicy
	if o.DeliverSubject != nil {
		toSerialize["deliver_subject"] = o.DeliverSubject
	}
	if o.Description != nil {
		toSerialize["description"] = o.Description
	}
	if o.Direct != nil {
		toSerialize["direct"] = o.Direct
	}
	if o.DurableName != nil {
		toSerialize["durable_name"] = o.DurableName
	}
	if o.FilterSubject != nil {
		toSerialize["filter_subject"] = o.FilterSubject
	}
	if len(o.FilterSubjects) != 0 {
		toSerialize["filter_subjects"] = o.FilterSubjects
	}
	if o.FlowControl != nil {
		toSerialize["flow_control"] = o.FlowControl
	}
	if o.HeadersOnly != nil {
		toSerialize["headers_only"] = o.HeadersOnly
	}
	if o.IdleHeartbeat != nil {
		toSerialize["idle_heartbeat"] = o.IdleHeartbeat
	}
	if o.InactiveThreshold != nil {
		toSerialize["inactive_threshold"] = o.InactiveThreshold
	}
	if o.MaxAckPending != nil {
		toSerialize["max_ack_pending"] = o.MaxAckPending
	}
	if o.MaxBatch != nil {
		toSerialize["max_batch"] = o.MaxBatch
	}
	if o.MaxBytes != nil {
		toSerialize["max_bytes"] = o.MaxBytes
	}
	if o.MaxDeliver != nil {
		toSerialize["max_deliver"] = o.MaxDeliver
	}
	if o.MaxExpires != nil {
		toSerialize["max_expires"] = o.MaxExpires
	}
	if o.MaxWaiting != nil {
		toSerialize["max_waiting"] = o.MaxWaiting
	}
	if o.MemStorage != nil {
		toSerialize["mem_storage"] = o.MemStorage
	}
	if len(o.Metadata) != 0 {
		toSerialize["metadata"] = o.Metadata
	}
	if o.Name != nil {
		toSerialize["name"] = o.Name
	}
	toSerialize["num_replicas"] = o.NumReplicas
	if o.OptStartSeq != nil {
		toSerialize["opt_start_seq"] = o.OptStartSeq
	}
	if o.OptStartTime != nil && !o.OptStartTime.IsNull() {
		toSerialize["opt_start_time"] = o.OptStartTime.Val
	}
	if o.RateLimitBps != nil {
		toSerialize["rate_limit_bps"] = o.RateLimitBps
	}
	toSerialize["replay_policy"] = o.ReplayPolicy
	if o.SampleFreq != nil {
		toSerialize["sample_freq"] = o.SampleFreq
	}
	return toSerialize, nil
}
