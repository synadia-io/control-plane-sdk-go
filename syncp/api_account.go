/*
Synadia Control Plane

API for Synadia Control Plane Server

API version: beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package syncp

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type AccountAPI interface {

	/*
		AssignAccountTeamAppUser Assign Team App User to Account

		Assign a Team App User to an Account. This operation is idempotent; if an App User is already assigned to the Account the assignemnt will be updated with the new role

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@param teamAppUserId
		@return ApiAssignAccountTeamAppUserRequest
	*/
	AssignAccountTeamAppUser(ctx context.Context, accountId string, teamAppUserId string) ApiAssignAccountTeamAppUserRequest

	// AssignAccountTeamAppUserExecute executes the request
	//  @return AppUserAssignResponse
	AssignAccountTeamAppUserExecute(r ApiAssignAccountTeamAppUserRequest) (*AppUserAssignResponse, *http.Response, error)

	/*
		CreateAccountSkGroup Create Account Signing Key Group

		Creates Account Signing Key Group

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateAccountSkGroupRequest
	*/
	CreateAccountSkGroup(ctx context.Context, accountId string) ApiCreateAccountSkGroupRequest

	// CreateAccountSkGroupExecute executes the request
	//  @return SigningKeyGroupCreateResponse
	CreateAccountSkGroupExecute(r ApiCreateAccountSkGroupRequest) (*SigningKeyGroupCreateResponse, *http.Response, error)

	/*
		CreateAlertRule Create Account Alert Rule

		Creates Account Alert Rule

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateAlertRuleRequest
	*/
	CreateAlertRule(ctx context.Context, accountId string) ApiCreateAlertRuleRequest

	// CreateAlertRuleExecute executes the request
	//  @return AlertRuleViewResponse
	CreateAlertRuleExecute(r ApiCreateAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error)

	/*
		CreateKvBucket Create KV Bucket

		Creates KV Bucket

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateKvBucketRequest
	*/
	CreateKvBucket(ctx context.Context, accountId string) ApiCreateKvBucketRequest

	// CreateKvBucketExecute executes the request
	//  @return JSKVBucketViewResponse
	CreateKvBucketExecute(r ApiCreateKvBucketRequest) (*JSKVBucketViewResponse, *http.Response, error)

	/*
		CreateMirror Create Mirror

		Creates Mirror

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateMirrorRequest
	*/
	CreateMirror(ctx context.Context, accountId string) ApiCreateMirrorRequest

	// CreateMirrorExecute executes the request
	//  @return JSMirrorInfoResponse
	CreateMirrorExecute(r ApiCreateMirrorRequest) (*JSMirrorInfoResponse, *http.Response, error)

	/*
		CreateObjectBucket Create Object Bucket

		Creates Object Bucket

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateObjectBucketRequest
	*/
	CreateObjectBucket(ctx context.Context, accountId string) ApiCreateObjectBucketRequest

	// CreateObjectBucketExecute executes the request
	//  @return JSObjectBucketViewResponse
	CreateObjectBucketExecute(r ApiCreateObjectBucketRequest) (*JSObjectBucketViewResponse, *http.Response, error)

	/*
		CreateOrUpdateNatsUserRevocation Create or Update Revocation for a NATS User NKey

		Creates or Updates a Revocation for the given NATS User NKey. All users issued prior to 'before' will be revoked. If 'before' is set to 0, the current timestamp will be used.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@param userNkeyPublic
		@return ApiCreateOrUpdateNatsUserRevocationRequest
	*/
	CreateOrUpdateNatsUserRevocation(ctx context.Context, accountId string, userNkeyPublic string) ApiCreateOrUpdateNatsUserRevocationRequest

	// CreateOrUpdateNatsUserRevocationExecute executes the request
	//  @return NatsUserRevocationViewResponse
	CreateOrUpdateNatsUserRevocationExecute(r ApiCreateOrUpdateNatsUserRevocationRequest) (*NatsUserRevocationViewResponse, *http.Response, error)

	/*
		CreateStream Create Stream

		Create Stream

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateStreamRequest
	*/
	CreateStream(ctx context.Context, accountId string) ApiCreateStreamRequest

	// CreateStreamExecute executes the request
	//  @return JSStreamInfoResponse
	CreateStreamExecute(r ApiCreateStreamRequest) (*JSStreamInfoResponse, *http.Response, error)

	/*
		CreateStreamExport Create Stream Export

		Creates Stream Export

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateStreamExportRequest
	*/
	CreateStreamExport(ctx context.Context, accountId string) ApiCreateStreamExportRequest

	// CreateStreamExportExecute executes the request
	//  @return StreamExportViewResponse
	CreateStreamExportExecute(r ApiCreateStreamExportRequest) (*StreamExportViewResponse, *http.Response, error)

	/*
		CreateStreamImport Create Stream Import

		Creates Stream Import

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateStreamImportRequest
	*/
	CreateStreamImport(ctx context.Context, accountId string) ApiCreateStreamImportRequest

	// CreateStreamImportExecute executes the request
	//  @return StreamImportViewResponse
	CreateStreamImportExecute(r ApiCreateStreamImportRequest) (*StreamImportViewResponse, *http.Response, error)

	/*
		CreateSubjectExport Create Subject Export

		Creates Subject Export

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateSubjectExportRequest
	*/
	CreateSubjectExport(ctx context.Context, accountId string) ApiCreateSubjectExportRequest

	// CreateSubjectExportExecute executes the request
	//  @return SubjectExportViewResponse
	CreateSubjectExportExecute(r ApiCreateSubjectExportRequest) (*SubjectExportViewResponse, *http.Response, error)

	/*
		CreateSubjectImport Create Subject Import

		Creates Subject Import

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateSubjectImportRequest
	*/
	CreateSubjectImport(ctx context.Context, accountId string) ApiCreateSubjectImportRequest

	// CreateSubjectImportExecute executes the request
	//  @return SubjectImportViewResponse
	CreateSubjectImportExecute(r ApiCreateSubjectImportRequest) (*SubjectImportViewResponse, *http.Response, error)

	/*
		CreateUser Create NATS User

		Creates a NATS user for an account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiCreateUserRequest
	*/
	CreateUser(ctx context.Context, accountId string) ApiCreateUserRequest

	// CreateUserExecute executes the request
	//  @return NatsUserViewResponse
	CreateUserExecute(r ApiCreateUserRequest) (*NatsUserViewResponse, *http.Response, error)

	/*
		DeleteAccount Delete Account

		Deletes a Account in a system

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiDeleteAccountRequest
	*/
	DeleteAccount(ctx context.Context, accountId string) ApiDeleteAccountRequest

	// DeleteAccountExecute executes the request
	DeleteAccountExecute(r ApiDeleteAccountRequest) (*http.Response, error)

	/*
		DeleteAlertRule Delete Account Alert Rule

		Deletes Account alert rule

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@param alertRuleId
		@return ApiDeleteAlertRuleRequest
	*/
	DeleteAlertRule(ctx context.Context, accountId string, alertRuleId string) ApiDeleteAlertRuleRequest

	// DeleteAlertRuleExecute executes the request
	DeleteAlertRuleExecute(r ApiDeleteAlertRuleRequest) (*http.Response, error)

	/*
		DeleteNatsUserRevocation Delete a for a NATS User NKey

		Deletes a Revocation for the given NATS User NKey

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@param userNkeyPublic
		@return ApiDeleteNatsUserRevocationRequest
	*/
	DeleteNatsUserRevocation(ctx context.Context, accountId string, userNkeyPublic string) ApiDeleteNatsUserRevocationRequest

	// DeleteNatsUserRevocationExecute executes the request
	DeleteNatsUserRevocationExecute(r ApiDeleteNatsUserRevocationRequest) (*http.Response, error)

	/*
		GetAccount Get Account

		Returns a Account by ID

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiGetAccountRequest
	*/
	GetAccount(ctx context.Context, accountId string) ApiGetAccountRequest

	// GetAccountExecute executes the request
	//  @return AccountViewResponse
	GetAccountExecute(r ApiGetAccountRequest) (*AccountViewResponse, *http.Response, error)

	/*
		GetAccountInfo Get Account Info

		Returns Account info

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiGetAccountInfoRequest
	*/
	GetAccountInfo(ctx context.Context, accountId string) ApiGetAccountInfoRequest

	// GetAccountInfoExecute executes the request
	//  @return JetStreamAccountStats
	GetAccountInfoExecute(r ApiGetAccountInfoRequest) (*JetStreamAccountStats, *http.Response, error)

	/*
		GetAccountMetrics Get Account Metrics

		Returns Account metrics

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiGetAccountMetricsRequest
	*/
	GetAccountMetrics(ctx context.Context, accountId string) ApiGetAccountMetricsRequest

	// GetAccountMetricsExecute executes the request
	//  @return AccountMetrics
	GetAccountMetricsExecute(r ApiGetAccountMetricsRequest) (*AccountMetrics, *http.Response, error)

	/*
		GetAlertRule Get Account Alert Rule

		Get Account Alert Rule

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@param alertRuleId
		@return ApiGetAlertRuleRequest
	*/
	GetAlertRule(ctx context.Context, accountId string, alertRuleId string) ApiGetAlertRuleRequest

	// GetAlertRuleExecute executes the request
	//  @return AlertRuleViewResponse
	GetAlertRuleExecute(r ApiGetAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error)

	/*
		GetJetStreamPlacementOptions Get JetStream Placement Options

		Get available options for JetStream placement

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiGetJetStreamPlacementOptionsRequest
	*/
	GetJetStreamPlacementOptions(ctx context.Context, accountId string) ApiGetJetStreamPlacementOptionsRequest

	// GetJetStreamPlacementOptionsExecute executes the request
	//  @return JSPlacementOptionsResponse
	GetJetStreamPlacementOptionsExecute(r ApiGetJetStreamPlacementOptionsRequest) (*JSPlacementOptionsResponse, *http.Response, error)

	/*
		GetNatsUserRevocation Get Revocation for a NATS User NKey

		Get Revocation for the given NATS User NKey

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@param userNkeyPublic
		@return ApiGetNatsUserRevocationRequest
	*/
	GetNatsUserRevocation(ctx context.Context, accountId string, userNkeyPublic string) ApiGetNatsUserRevocationRequest

	// GetNatsUserRevocationExecute executes the request
	//  @return NatsUserRevocationViewResponse
	GetNatsUserRevocationExecute(r ApiGetNatsUserRevocationRequest) (*NatsUserRevocationViewResponse, *http.Response, error)

	/*
		ListAccountConnections List Account Connections

		List Account Connections

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListAccountConnectionsRequest
	*/
	ListAccountConnections(ctx context.Context, accountId string) ApiListAccountConnectionsRequest

	// ListAccountConnectionsExecute executes the request
	//  @return AccountConnectionsListResponse
	ListAccountConnectionsExecute(r ApiListAccountConnectionsRequest) (*AccountConnectionsListResponse, *http.Response, error)

	/*
		ListAccountSkGroup List Account Signing Key Groups

		List Account Signing Key Groups

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListAccountSkGroupRequest
	*/
	ListAccountSkGroup(ctx context.Context, accountId string) ApiListAccountSkGroupRequest

	// ListAccountSkGroupExecute executes the request
	//  @return SigningKeyGroupListResponse
	ListAccountSkGroupExecute(r ApiListAccountSkGroupRequest) (*SigningKeyGroupListResponse, *http.Response, error)

	/*
		ListAccountTeamAppUsers List Account Team App Users

		Returns a list of Team App Users associated with the Account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListAccountTeamAppUsersRequest
	*/
	ListAccountTeamAppUsers(ctx context.Context, accountId string) ApiListAccountTeamAppUsersRequest

	// ListAccountTeamAppUsersExecute executes the request
	//  @return AppUserAssignListResponse
	ListAccountTeamAppUsersExecute(r ApiListAccountTeamAppUsersRequest) (*AppUserAssignListResponse, *http.Response, error)

	/*
		ListAlertRules List Account Alert Rules

		List Account Alert Rules

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListAlertRulesRequest
	*/
	ListAlertRules(ctx context.Context, accountId string) ApiListAlertRulesRequest

	// ListAlertRulesExecute executes the request
	//  @return AlertRuleListResponse
	ListAlertRulesExecute(r ApiListAlertRulesRequest) (*AlertRuleListResponse, *http.Response, error)

	/*
		ListJetStreamAssets List JetStream Assets

		List JetStream Assets

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListJetStreamAssetsRequest
	*/
	ListJetStreamAssets(ctx context.Context, accountId string) ApiListJetStreamAssetsRequest

	// ListJetStreamAssetsExecute executes the request
	//  @return JSAssetInfoListResponse
	ListJetStreamAssetsExecute(r ApiListJetStreamAssetsRequest) (*JSAssetInfoListResponse, *http.Response, error)

	/*
		ListKvBuckets List KV buckets

		List KV buckets

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListKvBucketsRequest
	*/
	ListKvBuckets(ctx context.Context, accountId string) ApiListKvBucketsRequest

	// ListKvBucketsExecute executes the request
	//  @return JSKVBucketListResponse
	ListKvBucketsExecute(r ApiListKvBucketsRequest) (*JSKVBucketListResponse, *http.Response, error)

	/*
		ListMirrors List Mirrors

		List Mirrors

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListMirrorsRequest
	*/
	ListMirrors(ctx context.Context, accountId string) ApiListMirrorsRequest

	// ListMirrorsExecute executes the request
	//  @return JSMirrorInfoListResponse
	ListMirrorsExecute(r ApiListMirrorsRequest) (*JSMirrorInfoListResponse, *http.Response, error)

	/*
		ListObjectBuckets List Object buckets

		List Object buckets

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListObjectBucketsRequest
	*/
	ListObjectBuckets(ctx context.Context, accountId string) ApiListObjectBucketsRequest

	// ListObjectBucketsExecute executes the request
	//  @return JSObjectBucketListResponse
	ListObjectBucketsExecute(r ApiListObjectBucketsRequest) (*JSObjectBucketListResponse, *http.Response, error)

	/*
		ListStreamExports List Stream Exports

		List Stream Exports

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListStreamExportsRequest
	*/
	ListStreamExports(ctx context.Context, accountId string) ApiListStreamExportsRequest

	// ListStreamExportsExecute executes the request
	//  @return StreamExportListResponse
	ListStreamExportsExecute(r ApiListStreamExportsRequest) (*StreamExportListResponse, *http.Response, error)

	/*
		ListStreamExportsShared List Shared Stream Exports

		List stream exports shared with this account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListStreamExportsSharedRequest
	*/
	ListStreamExportsShared(ctx context.Context, accountId string) ApiListStreamExportsSharedRequest

	// ListStreamExportsSharedExecute executes the request
	//  @return StreamExportSharedListResponse
	ListStreamExportsSharedExecute(r ApiListStreamExportsSharedRequest) (*StreamExportSharedListResponse, *http.Response, error)

	/*
		ListStreamImports List Stream Imports

		List Stream Imports

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListStreamImportsRequest
	*/
	ListStreamImports(ctx context.Context, accountId string) ApiListStreamImportsRequest

	// ListStreamImportsExecute executes the request
	//  @return StreamImportListResponse
	ListStreamImportsExecute(r ApiListStreamImportsRequest) (*StreamImportListResponse, *http.Response, error)

	/*
		ListStreams List Streams

		List Streams

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListStreamsRequest
	*/
	ListStreams(ctx context.Context, accountId string) ApiListStreamsRequest

	// ListStreamsExecute executes the request
	//  @return JSStreamInfoListResponse
	ListStreamsExecute(r ApiListStreamsRequest) (*JSStreamInfoListResponse, *http.Response, error)

	/*
		ListSubjectExports List Subject Exports

		List Subject Exports

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListSubjectExportsRequest
	*/
	ListSubjectExports(ctx context.Context, accountId string) ApiListSubjectExportsRequest

	// ListSubjectExportsExecute executes the request
	//  @return SubjectExportListResponse
	ListSubjectExportsExecute(r ApiListSubjectExportsRequest) (*SubjectExportListResponse, *http.Response, error)

	/*
		ListSubjectExportsShared List Shared Subject Exports

		List subject exports shared with this account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListSubjectExportsSharedRequest
	*/
	ListSubjectExportsShared(ctx context.Context, accountId string) ApiListSubjectExportsSharedRequest

	// ListSubjectExportsSharedExecute executes the request
	//  @return SubjectExportSharedListResponse
	ListSubjectExportsSharedExecute(r ApiListSubjectExportsSharedRequest) (*SubjectExportSharedListResponse, *http.Response, error)

	/*
		ListSubjectImports List Subject Imports

		List Subject Imports

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListSubjectImportsRequest
	*/
	ListSubjectImports(ctx context.Context, accountId string) ApiListSubjectImportsRequest

	// ListSubjectImportsExecute executes the request
	//  @return SubjectImportListResponse
	ListSubjectImportsExecute(r ApiListSubjectImportsRequest) (*SubjectImportListResponse, *http.Response, error)

	/*
		ListUsers List NATS Users

		Returns a list of NATS users for the given account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiListUsersRequest
	*/
	ListUsers(ctx context.Context, accountId string) ApiListUsersRequest

	// ListUsersExecute executes the request
	//  @return NatsUserListResponse
	ListUsersExecute(r ApiListUsersRequest) (*NatsUserListResponse, *http.Response, error)

	/*
		RunAlertRule Run Account Alert Rule

		Run Account Alert Rule and return an alert object if the rule condition is met

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@param alertRuleId
		@return ApiRunAlertRuleRequest
	*/
	RunAlertRule(ctx context.Context, accountId string, alertRuleId string) ApiRunAlertRuleRequest

	// RunAlertRuleExecute executes the request
	//  @return AlertViewResponse
	RunAlertRuleExecute(r ApiRunAlertRuleRequest) (*AlertViewResponse, *http.Response, error)

	/*
		UnAssignAccountTeamAppUser Unassign Team App User from Account

		Unassign a Team App User from an Account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@param teamAppUserId
		@return ApiUnAssignAccountTeamAppUserRequest
	*/
	UnAssignAccountTeamAppUser(ctx context.Context, accountId string, teamAppUserId string) ApiUnAssignAccountTeamAppUserRequest

	// UnAssignAccountTeamAppUserExecute executes the request
	UnAssignAccountTeamAppUserExecute(r ApiUnAssignAccountTeamAppUserRequest) (*http.Response, error)

	/*
		UnmanageAccount Unmanage Account

		Unmanage a Account in a system

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiUnmanageAccountRequest
	*/
	UnmanageAccount(ctx context.Context, accountId string) ApiUnmanageAccountRequest

	// UnmanageAccountExecute executes the request
	UnmanageAccountExecute(r ApiUnmanageAccountRequest) (*http.Response, error)

	/*
		UpdateAccount Update Account

		Updates a Account in a system

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@return ApiUpdateAccountRequest
	*/
	UpdateAccount(ctx context.Context, accountId string) ApiUpdateAccountRequest

	// UpdateAccountExecute executes the request
	//  @return AccountViewResponse
	UpdateAccountExecute(r ApiUpdateAccountRequest) (*AccountViewResponse, *http.Response, error)

	/*
		UpdateAlertRule Update Account Alert Rule

		Update Account Alert Rule

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param accountId
		@param alertRuleId
		@return ApiUpdateAlertRuleRequest
	*/
	UpdateAlertRule(ctx context.Context, accountId string, alertRuleId string) ApiUpdateAlertRuleRequest

	// UpdateAlertRuleExecute executes the request
	//  @return AlertRuleViewResponse
	UpdateAlertRuleExecute(r ApiUpdateAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error)
}

// AccountAPIService AccountAPI service
type AccountAPIService service

type ApiAssignAccountTeamAppUserRequest struct {
	ctx                  context.Context
	ApiService           AccountAPI
	accountId            string
	teamAppUserId        string
	appUserAssignRequest *AppUserAssignRequest
}

func (r ApiAssignAccountTeamAppUserRequest) AppUserAssignRequest(appUserAssignRequest AppUserAssignRequest) ApiAssignAccountTeamAppUserRequest {
	r.appUserAssignRequest = &appUserAssignRequest
	return r
}

func (r ApiAssignAccountTeamAppUserRequest) Execute() (*AppUserAssignResponse, *http.Response, error) {
	return r.ApiService.AssignAccountTeamAppUserExecute(r)
}

/*
AssignAccountTeamAppUser Assign Team App User to Account

Assign a Team App User to an Account. This operation is idempotent; if an App User is already assigned to the Account the assignemnt will be updated with the new role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@param teamAppUserId
	@return ApiAssignAccountTeamAppUserRequest
*/
func (a *AccountAPIService) AssignAccountTeamAppUser(ctx context.Context, accountId string, teamAppUserId string) ApiAssignAccountTeamAppUserRequest {
	return ApiAssignAccountTeamAppUserRequest{
		ApiService:    a,
		ctx:           ctx,
		accountId:     accountId,
		teamAppUserId: teamAppUserId,
	}
}

// Execute executes the request
//
//	@return AppUserAssignResponse
func (a *AccountAPIService) AssignAccountTeamAppUserExecute(r ApiAssignAccountTeamAppUserRequest) (*AppUserAssignResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppUserAssignResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.AssignAccountTeamAppUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/app-users/{teamAppUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamAppUserId"+"}", url.PathEscape(parameterValueToString(r.teamAppUserId, "teamAppUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appUserAssignRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAccountSkGroupRequest struct {
	ctx                          context.Context
	ApiService                   AccountAPI
	accountId                    string
	signingKeyGroupCreateRequest *SigningKeyGroupCreateRequest
}

func (r ApiCreateAccountSkGroupRequest) SigningKeyGroupCreateRequest(signingKeyGroupCreateRequest SigningKeyGroupCreateRequest) ApiCreateAccountSkGroupRequest {
	r.signingKeyGroupCreateRequest = &signingKeyGroupCreateRequest
	return r
}

func (r ApiCreateAccountSkGroupRequest) Execute() (*SigningKeyGroupCreateResponse, *http.Response, error) {
	return r.ApiService.CreateAccountSkGroupExecute(r)
}

/*
CreateAccountSkGroup Create Account Signing Key Group

Creates Account Signing Key Group

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateAccountSkGroupRequest
*/
func (a *AccountAPIService) CreateAccountSkGroup(ctx context.Context, accountId string) ApiCreateAccountSkGroupRequest {
	return ApiCreateAccountSkGroupRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return SigningKeyGroupCreateResponse
func (a *AccountAPIService) CreateAccountSkGroupExecute(r ApiCreateAccountSkGroupRequest) (*SigningKeyGroupCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SigningKeyGroupCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateAccountSkGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/account-sk-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signingKeyGroupCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAlertRuleRequest struct {
	ctx                           context.Context
	ApiService                    AccountAPI
	accountId                     string
	alertRuleAccountCreateRequest *AlertRuleAccountCreateRequest
}

func (r ApiCreateAlertRuleRequest) AlertRuleAccountCreateRequest(alertRuleAccountCreateRequest AlertRuleAccountCreateRequest) ApiCreateAlertRuleRequest {
	r.alertRuleAccountCreateRequest = &alertRuleAccountCreateRequest
	return r
}

func (r ApiCreateAlertRuleRequest) Execute() (*AlertRuleViewResponse, *http.Response, error) {
	return r.ApiService.CreateAlertRuleExecute(r)
}

/*
CreateAlertRule Create Account Alert Rule

Creates Account Alert Rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateAlertRuleRequest
*/
func (a *AccountAPIService) CreateAlertRule(ctx context.Context, accountId string) ApiCreateAlertRuleRequest {
	return ApiCreateAlertRuleRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return AlertRuleViewResponse
func (a *AccountAPIService) CreateAlertRuleExecute(r ApiCreateAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRuleViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateAlertRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/alert-rules"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alertRuleAccountCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateKvBucketRequest struct {
	ctx              context.Context
	ApiService       AccountAPI
	accountId        string
	jSKVBucketConfig *JSKVBucketConfig
}

func (r ApiCreateKvBucketRequest) JSKVBucketConfig(jSKVBucketConfig JSKVBucketConfig) ApiCreateKvBucketRequest {
	r.jSKVBucketConfig = &jSKVBucketConfig
	return r
}

func (r ApiCreateKvBucketRequest) Execute() (*JSKVBucketViewResponse, *http.Response, error) {
	return r.ApiService.CreateKvBucketExecute(r)
}

/*
CreateKvBucket Create KV Bucket

Creates KV Bucket

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateKvBucketRequest
*/
func (a *AccountAPIService) CreateKvBucket(ctx context.Context, accountId string) ApiCreateKvBucketRequest {
	return ApiCreateKvBucketRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JSKVBucketViewResponse
func (a *AccountAPIService) CreateKvBucketExecute(r ApiCreateKvBucketRequest) (*JSKVBucketViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JSKVBucketViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateKvBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/jetstream/kv-buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jSKVBucketConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMirrorRequest struct {
	ctx                   context.Context
	ApiService            AccountAPI
	accountId             string
	jSMirrorConfigRequest *JSMirrorConfigRequest
}

func (r ApiCreateMirrorRequest) JSMirrorConfigRequest(jSMirrorConfigRequest JSMirrorConfigRequest) ApiCreateMirrorRequest {
	r.jSMirrorConfigRequest = &jSMirrorConfigRequest
	return r
}

func (r ApiCreateMirrorRequest) Execute() (*JSMirrorInfoResponse, *http.Response, error) {
	return r.ApiService.CreateMirrorExecute(r)
}

/*
CreateMirror Create Mirror

Creates Mirror

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateMirrorRequest
*/
func (a *AccountAPIService) CreateMirror(ctx context.Context, accountId string) ApiCreateMirrorRequest {
	return ApiCreateMirrorRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JSMirrorInfoResponse
func (a *AccountAPIService) CreateMirrorExecute(r ApiCreateMirrorRequest) (*JSMirrorInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JSMirrorInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateMirror")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/jetstream/mirrors"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jSMirrorConfigRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateObjectBucketRequest struct {
	ctx                  context.Context
	ApiService           AccountAPI
	accountId            string
	jSObjectBucketConfig *JSObjectBucketConfig
}

func (r ApiCreateObjectBucketRequest) JSObjectBucketConfig(jSObjectBucketConfig JSObjectBucketConfig) ApiCreateObjectBucketRequest {
	r.jSObjectBucketConfig = &jSObjectBucketConfig
	return r
}

func (r ApiCreateObjectBucketRequest) Execute() (*JSObjectBucketViewResponse, *http.Response, error) {
	return r.ApiService.CreateObjectBucketExecute(r)
}

/*
CreateObjectBucket Create Object Bucket

Creates Object Bucket

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateObjectBucketRequest
*/
func (a *AccountAPIService) CreateObjectBucket(ctx context.Context, accountId string) ApiCreateObjectBucketRequest {
	return ApiCreateObjectBucketRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JSObjectBucketViewResponse
func (a *AccountAPIService) CreateObjectBucketExecute(r ApiCreateObjectBucketRequest) (*JSObjectBucketViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JSObjectBucketViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateObjectBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/jetstream/object-buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jSObjectBucketConfig
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrUpdateNatsUserRevocationRequest struct {
	ctx                       context.Context
	ApiService                AccountAPI
	accountId                 string
	userNkeyPublic            string
	natsUserRevocationRequest *NatsUserRevocationRequest
}

func (r ApiCreateOrUpdateNatsUserRevocationRequest) NatsUserRevocationRequest(natsUserRevocationRequest NatsUserRevocationRequest) ApiCreateOrUpdateNatsUserRevocationRequest {
	r.natsUserRevocationRequest = &natsUserRevocationRequest
	return r
}

func (r ApiCreateOrUpdateNatsUserRevocationRequest) Execute() (*NatsUserRevocationViewResponse, *http.Response, error) {
	return r.ApiService.CreateOrUpdateNatsUserRevocationExecute(r)
}

/*
CreateOrUpdateNatsUserRevocation Create or Update Revocation for a NATS User NKey

Creates or Updates a Revocation for the given NATS User NKey. All users issued prior to 'before' will be revoked. If 'before' is set to 0, the current timestamp will be used.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@param userNkeyPublic
	@return ApiCreateOrUpdateNatsUserRevocationRequest
*/
func (a *AccountAPIService) CreateOrUpdateNatsUserRevocation(ctx context.Context, accountId string, userNkeyPublic string) ApiCreateOrUpdateNatsUserRevocationRequest {
	return ApiCreateOrUpdateNatsUserRevocationRequest{
		ApiService:     a,
		ctx:            ctx,
		accountId:      accountId,
		userNkeyPublic: userNkeyPublic,
	}
}

// Execute executes the request
//
//	@return NatsUserRevocationViewResponse
func (a *AccountAPIService) CreateOrUpdateNatsUserRevocationExecute(r ApiCreateOrUpdateNatsUserRevocationRequest) (*NatsUserRevocationViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserRevocationViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateOrUpdateNatsUserRevocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/nats-user-revocations/{userNkeyPublic}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userNkeyPublic"+"}", url.PathEscape(parameterValueToString(r.userNkeyPublic, "userNkeyPublic")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.natsUserRevocationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStreamRequest struct {
	ctx                   context.Context
	ApiService            AccountAPI
	accountId             string
	jSStreamConfigRequest *JSStreamConfigRequest
}

func (r ApiCreateStreamRequest) JSStreamConfigRequest(jSStreamConfigRequest JSStreamConfigRequest) ApiCreateStreamRequest {
	r.jSStreamConfigRequest = &jSStreamConfigRequest
	return r
}

func (r ApiCreateStreamRequest) Execute() (*JSStreamInfoResponse, *http.Response, error) {
	return r.ApiService.CreateStreamExecute(r)
}

/*
CreateStream Create Stream

Create Stream

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateStreamRequest
*/
func (a *AccountAPIService) CreateStream(ctx context.Context, accountId string) ApiCreateStreamRequest {
	return ApiCreateStreamRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JSStreamInfoResponse
func (a *AccountAPIService) CreateStreamExecute(r ApiCreateStreamRequest) (*JSStreamInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JSStreamInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/jetstream/streams"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jSStreamConfigRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStreamExportRequest struct {
	ctx                       context.Context
	ApiService                AccountAPI
	accountId                 string
	streamExportCreateRequest *StreamExportCreateRequest
}

func (r ApiCreateStreamExportRequest) StreamExportCreateRequest(streamExportCreateRequest StreamExportCreateRequest) ApiCreateStreamExportRequest {
	r.streamExportCreateRequest = &streamExportCreateRequest
	return r
}

func (r ApiCreateStreamExportRequest) Execute() (*StreamExportViewResponse, *http.Response, error) {
	return r.ApiService.CreateStreamExportExecute(r)
}

/*
CreateStreamExport Create Stream Export

Creates Stream Export

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateStreamExportRequest
*/
func (a *AccountAPIService) CreateStreamExport(ctx context.Context, accountId string) ApiCreateStreamExportRequest {
	return ApiCreateStreamExportRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return StreamExportViewResponse
func (a *AccountAPIService) CreateStreamExportExecute(r ApiCreateStreamExportRequest) (*StreamExportViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StreamExportViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateStreamExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/stream-exports"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.streamExportCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStreamImportRequest struct {
	ctx                       context.Context
	ApiService                AccountAPI
	accountId                 string
	streamImportCreateRequest *StreamImportCreateRequest
}

func (r ApiCreateStreamImportRequest) StreamImportCreateRequest(streamImportCreateRequest StreamImportCreateRequest) ApiCreateStreamImportRequest {
	r.streamImportCreateRequest = &streamImportCreateRequest
	return r
}

func (r ApiCreateStreamImportRequest) Execute() (*StreamImportViewResponse, *http.Response, error) {
	return r.ApiService.CreateStreamImportExecute(r)
}

/*
CreateStreamImport Create Stream Import

Creates Stream Import

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateStreamImportRequest
*/
func (a *AccountAPIService) CreateStreamImport(ctx context.Context, accountId string) ApiCreateStreamImportRequest {
	return ApiCreateStreamImportRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return StreamImportViewResponse
func (a *AccountAPIService) CreateStreamImportExecute(r ApiCreateStreamImportRequest) (*StreamImportViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StreamImportViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateStreamImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/stream-imports"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.streamImportCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubjectExportRequest struct {
	ctx                        context.Context
	ApiService                 AccountAPI
	accountId                  string
	subjectExportCreateRequest *SubjectExportCreateRequest
}

func (r ApiCreateSubjectExportRequest) SubjectExportCreateRequest(subjectExportCreateRequest SubjectExportCreateRequest) ApiCreateSubjectExportRequest {
	r.subjectExportCreateRequest = &subjectExportCreateRequest
	return r
}

func (r ApiCreateSubjectExportRequest) Execute() (*SubjectExportViewResponse, *http.Response, error) {
	return r.ApiService.CreateSubjectExportExecute(r)
}

/*
CreateSubjectExport Create Subject Export

Creates Subject Export

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateSubjectExportRequest
*/
func (a *AccountAPIService) CreateSubjectExport(ctx context.Context, accountId string) ApiCreateSubjectExportRequest {
	return ApiCreateSubjectExportRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return SubjectExportViewResponse
func (a *AccountAPIService) CreateSubjectExportExecute(r ApiCreateSubjectExportRequest) (*SubjectExportViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubjectExportViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateSubjectExport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/subject-exports"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subjectExportCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSubjectImportRequest struct {
	ctx                        context.Context
	ApiService                 AccountAPI
	accountId                  string
	subjectImportCreateRequest *SubjectImportCreateRequest
}

func (r ApiCreateSubjectImportRequest) SubjectImportCreateRequest(subjectImportCreateRequest SubjectImportCreateRequest) ApiCreateSubjectImportRequest {
	r.subjectImportCreateRequest = &subjectImportCreateRequest
	return r
}

func (r ApiCreateSubjectImportRequest) Execute() (*SubjectImportViewResponse, *http.Response, error) {
	return r.ApiService.CreateSubjectImportExecute(r)
}

/*
CreateSubjectImport Create Subject Import

Creates Subject Import

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateSubjectImportRequest
*/
func (a *AccountAPIService) CreateSubjectImport(ctx context.Context, accountId string) ApiCreateSubjectImportRequest {
	return ApiCreateSubjectImportRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return SubjectImportViewResponse
func (a *AccountAPIService) CreateSubjectImportExecute(r ApiCreateSubjectImportRequest) (*SubjectImportViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubjectImportViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateSubjectImport")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/subject-imports"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subjectImportCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateUserRequest struct {
	ctx                   context.Context
	ApiService            AccountAPI
	accountId             string
	natsUserCreateRequest *NatsUserCreateRequest
}

func (r ApiCreateUserRequest) NatsUserCreateRequest(natsUserCreateRequest NatsUserCreateRequest) ApiCreateUserRequest {
	r.natsUserCreateRequest = &natsUserCreateRequest
	return r
}

func (r ApiCreateUserRequest) Execute() (*NatsUserViewResponse, *http.Response, error) {
	return r.ApiService.CreateUserExecute(r)
}

/*
CreateUser Create NATS User

Creates a NATS user for an account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiCreateUserRequest
*/
func (a *AccountAPIService) CreateUser(ctx context.Context, accountId string) ApiCreateUserRequest {
	return ApiCreateUserRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return NatsUserViewResponse
func (a *AccountAPIService) CreateUserExecute(r ApiCreateUserRequest) (*NatsUserViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.CreateUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/nats-users"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.natsUserCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccountRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiDeleteAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAccountExecute(r)
}

/*
DeleteAccount Delete Account

Deletes a Account in a system

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiDeleteAccountRequest
*/
func (a *AccountAPIService) DeleteAccount(ctx context.Context, accountId string) ApiDeleteAccountRequest {
	return ApiDeleteAccountRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
func (a *AccountAPIService) DeleteAccountExecute(r ApiDeleteAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.DeleteAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAlertRuleRequest struct {
	ctx         context.Context
	ApiService  AccountAPI
	accountId   string
	alertRuleId string
}

func (r ApiDeleteAlertRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAlertRuleExecute(r)
}

/*
DeleteAlertRule Delete Account Alert Rule

Deletes Account alert rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@param alertRuleId
	@return ApiDeleteAlertRuleRequest
*/
func (a *AccountAPIService) DeleteAlertRule(ctx context.Context, accountId string, alertRuleId string) ApiDeleteAlertRuleRequest {
	return ApiDeleteAlertRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		accountId:   accountId,
		alertRuleId: alertRuleId,
	}
}

// Execute executes the request
func (a *AccountAPIService) DeleteAlertRuleExecute(r ApiDeleteAlertRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.DeleteAlertRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/alert-rules/{alertRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertRuleId"+"}", url.PathEscape(parameterValueToString(r.alertRuleId, "alertRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteNatsUserRevocationRequest struct {
	ctx            context.Context
	ApiService     AccountAPI
	accountId      string
	userNkeyPublic string
}

func (r ApiDeleteNatsUserRevocationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNatsUserRevocationExecute(r)
}

/*
DeleteNatsUserRevocation Delete a for a NATS User NKey

Deletes a Revocation for the given NATS User NKey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@param userNkeyPublic
	@return ApiDeleteNatsUserRevocationRequest
*/
func (a *AccountAPIService) DeleteNatsUserRevocation(ctx context.Context, accountId string, userNkeyPublic string) ApiDeleteNatsUserRevocationRequest {
	return ApiDeleteNatsUserRevocationRequest{
		ApiService:     a,
		ctx:            ctx,
		accountId:      accountId,
		userNkeyPublic: userNkeyPublic,
	}
}

// Execute executes the request
func (a *AccountAPIService) DeleteNatsUserRevocationExecute(r ApiDeleteNatsUserRevocationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.DeleteNatsUserRevocation")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/nats-user-revocations/{userNkeyPublic}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userNkeyPublic"+"}", url.PathEscape(parameterValueToString(r.userNkeyPublic, "userNkeyPublic")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAccountRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiGetAccountRequest) Execute() (*AccountViewResponse, *http.Response, error) {
	return r.ApiService.GetAccountExecute(r)
}

/*
GetAccount Get Account

Returns a Account by ID

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiGetAccountRequest
*/
func (a *AccountAPIService) GetAccount(ctx context.Context, accountId string) ApiGetAccountRequest {
	return ApiGetAccountRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return AccountViewResponse
func (a *AccountAPIService) GetAccountExecute(r ApiGetAccountRequest) (*AccountViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccountViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountInfoRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiGetAccountInfoRequest) Execute() (*JetStreamAccountStats, *http.Response, error) {
	return r.ApiService.GetAccountInfoExecute(r)
}

/*
GetAccountInfo Get Account Info

Returns Account info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiGetAccountInfoRequest
*/
func (a *AccountAPIService) GetAccountInfo(ctx context.Context, accountId string) ApiGetAccountInfoRequest {
	return ApiGetAccountInfoRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JetStreamAccountStats
func (a *AccountAPIService) GetAccountInfoExecute(r ApiGetAccountInfoRequest) (*JetStreamAccountStats, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JetStreamAccountStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.GetAccountInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/info"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountMetricsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiGetAccountMetricsRequest) Execute() (*AccountMetrics, *http.Response, error) {
	return r.ApiService.GetAccountMetricsExecute(r)
}

/*
GetAccountMetrics Get Account Metrics

Returns Account metrics

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiGetAccountMetricsRequest
*/
func (a *AccountAPIService) GetAccountMetrics(ctx context.Context, accountId string) ApiGetAccountMetricsRequest {
	return ApiGetAccountMetricsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return AccountMetrics
func (a *AccountAPIService) GetAccountMetricsExecute(r ApiGetAccountMetricsRequest) (*AccountMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccountMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.GetAccountMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlertRuleRequest struct {
	ctx         context.Context
	ApiService  AccountAPI
	accountId   string
	alertRuleId string
}

func (r ApiGetAlertRuleRequest) Execute() (*AlertRuleViewResponse, *http.Response, error) {
	return r.ApiService.GetAlertRuleExecute(r)
}

/*
GetAlertRule Get Account Alert Rule

Get Account Alert Rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@param alertRuleId
	@return ApiGetAlertRuleRequest
*/
func (a *AccountAPIService) GetAlertRule(ctx context.Context, accountId string, alertRuleId string) ApiGetAlertRuleRequest {
	return ApiGetAlertRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		accountId:   accountId,
		alertRuleId: alertRuleId,
	}
}

// Execute executes the request
//
//	@return AlertRuleViewResponse
func (a *AccountAPIService) GetAlertRuleExecute(r ApiGetAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRuleViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.GetAlertRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/alert-rules/{alertRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertRuleId"+"}", url.PathEscape(parameterValueToString(r.alertRuleId, "alertRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJetStreamPlacementOptionsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiGetJetStreamPlacementOptionsRequest) Execute() (*JSPlacementOptionsResponse, *http.Response, error) {
	return r.ApiService.GetJetStreamPlacementOptionsExecute(r)
}

/*
GetJetStreamPlacementOptions Get JetStream Placement Options

Get available options for JetStream placement

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiGetJetStreamPlacementOptionsRequest
*/
func (a *AccountAPIService) GetJetStreamPlacementOptions(ctx context.Context, accountId string) ApiGetJetStreamPlacementOptionsRequest {
	return ApiGetJetStreamPlacementOptionsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JSPlacementOptionsResponse
func (a *AccountAPIService) GetJetStreamPlacementOptionsExecute(r ApiGetJetStreamPlacementOptionsRequest) (*JSPlacementOptionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JSPlacementOptionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.GetJetStreamPlacementOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/jetstream/placement-options"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNatsUserRevocationRequest struct {
	ctx            context.Context
	ApiService     AccountAPI
	accountId      string
	userNkeyPublic string
}

func (r ApiGetNatsUserRevocationRequest) Execute() (*NatsUserRevocationViewResponse, *http.Response, error) {
	return r.ApiService.GetNatsUserRevocationExecute(r)
}

/*
GetNatsUserRevocation Get Revocation for a NATS User NKey

Get Revocation for the given NATS User NKey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@param userNkeyPublic
	@return ApiGetNatsUserRevocationRequest
*/
func (a *AccountAPIService) GetNatsUserRevocation(ctx context.Context, accountId string, userNkeyPublic string) ApiGetNatsUserRevocationRequest {
	return ApiGetNatsUserRevocationRequest{
		ApiService:     a,
		ctx:            ctx,
		accountId:      accountId,
		userNkeyPublic: userNkeyPublic,
	}
}

// Execute executes the request
//
//	@return NatsUserRevocationViewResponse
func (a *AccountAPIService) GetNatsUserRevocationExecute(r ApiGetNatsUserRevocationRequest) (*NatsUserRevocationViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserRevocationViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.GetNatsUserRevocation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/nats-user-revocations/{userNkeyPublic}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userNkeyPublic"+"}", url.PathEscape(parameterValueToString(r.userNkeyPublic, "userNkeyPublic")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAccountConnectionsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
	sort       *string
	cid        *string
	state      *string
	subject    *string
	limit      *float32
	user       *string
}

func (r ApiListAccountConnectionsRequest) Sort(sort string) ApiListAccountConnectionsRequest {
	r.sort = &sort
	return r
}

func (r ApiListAccountConnectionsRequest) Cid(cid string) ApiListAccountConnectionsRequest {
	r.cid = &cid
	return r
}

func (r ApiListAccountConnectionsRequest) State(state string) ApiListAccountConnectionsRequest {
	r.state = &state
	return r
}

func (r ApiListAccountConnectionsRequest) Subject(subject string) ApiListAccountConnectionsRequest {
	r.subject = &subject
	return r
}

func (r ApiListAccountConnectionsRequest) Limit(limit float32) ApiListAccountConnectionsRequest {
	r.limit = &limit
	return r
}

func (r ApiListAccountConnectionsRequest) User(user string) ApiListAccountConnectionsRequest {
	r.user = &user
	return r
}

func (r ApiListAccountConnectionsRequest) Execute() (*AccountConnectionsListResponse, *http.Response, error) {
	return r.ApiService.ListAccountConnectionsExecute(r)
}

/*
ListAccountConnections List Account Connections

List Account Connections

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListAccountConnectionsRequest
*/
func (a *AccountAPIService) ListAccountConnections(ctx context.Context, accountId string) ApiListAccountConnectionsRequest {
	return ApiListAccountConnectionsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return AccountConnectionsListResponse
func (a *AccountAPIService) ListAccountConnectionsExecute(r ApiListAccountConnectionsRequest) (*AccountConnectionsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccountConnectionsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListAccountConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/connections"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.cid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cid", r.cid, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.subject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subject", r.subject, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAccountSkGroupRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListAccountSkGroupRequest) Execute() (*SigningKeyGroupListResponse, *http.Response, error) {
	return r.ApiService.ListAccountSkGroupExecute(r)
}

/*
ListAccountSkGroup List Account Signing Key Groups

List Account Signing Key Groups

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListAccountSkGroupRequest
*/
func (a *AccountAPIService) ListAccountSkGroup(ctx context.Context, accountId string) ApiListAccountSkGroupRequest {
	return ApiListAccountSkGroupRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return SigningKeyGroupListResponse
func (a *AccountAPIService) ListAccountSkGroupExecute(r ApiListAccountSkGroupRequest) (*SigningKeyGroupListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SigningKeyGroupListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListAccountSkGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/account-sk-groups"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAccountTeamAppUsersRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListAccountTeamAppUsersRequest) Execute() (*AppUserAssignListResponse, *http.Response, error) {
	return r.ApiService.ListAccountTeamAppUsersExecute(r)
}

/*
ListAccountTeamAppUsers List Account Team App Users

Returns a list of Team App Users associated with the Account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListAccountTeamAppUsersRequest
*/
func (a *AccountAPIService) ListAccountTeamAppUsers(ctx context.Context, accountId string) ApiListAccountTeamAppUsersRequest {
	return ApiListAccountTeamAppUsersRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return AppUserAssignListResponse
func (a *AccountAPIService) ListAccountTeamAppUsersExecute(r ApiListAccountTeamAppUsersRequest) (*AppUserAssignListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppUserAssignListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListAccountTeamAppUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/app-users"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAlertRulesRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListAlertRulesRequest) Execute() (*AlertRuleListResponse, *http.Response, error) {
	return r.ApiService.ListAlertRulesExecute(r)
}

/*
ListAlertRules List Account Alert Rules

List Account Alert Rules

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListAlertRulesRequest
*/
func (a *AccountAPIService) ListAlertRules(ctx context.Context, accountId string) ApiListAlertRulesRequest {
	return ApiListAlertRulesRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return AlertRuleListResponse
func (a *AccountAPIService) ListAlertRulesExecute(r ApiListAlertRulesRequest) (*AlertRuleListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRuleListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListAlertRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/alert-rules"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListJetStreamAssetsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListJetStreamAssetsRequest) Execute() (*JSAssetInfoListResponse, *http.Response, error) {
	return r.ApiService.ListJetStreamAssetsExecute(r)
}

/*
ListJetStreamAssets List JetStream Assets

List JetStream Assets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListJetStreamAssetsRequest
*/
func (a *AccountAPIService) ListJetStreamAssets(ctx context.Context, accountId string) ApiListJetStreamAssetsRequest {
	return ApiListJetStreamAssetsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JSAssetInfoListResponse
func (a *AccountAPIService) ListJetStreamAssetsExecute(r ApiListJetStreamAssetsRequest) (*JSAssetInfoListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JSAssetInfoListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListJetStreamAssets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/jetstream"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListKvBucketsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListKvBucketsRequest) Execute() (*JSKVBucketListResponse, *http.Response, error) {
	return r.ApiService.ListKvBucketsExecute(r)
}

/*
ListKvBuckets List KV buckets

List KV buckets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListKvBucketsRequest
*/
func (a *AccountAPIService) ListKvBuckets(ctx context.Context, accountId string) ApiListKvBucketsRequest {
	return ApiListKvBucketsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JSKVBucketListResponse
func (a *AccountAPIService) ListKvBucketsExecute(r ApiListKvBucketsRequest) (*JSKVBucketListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JSKVBucketListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListKvBuckets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/jetstream/kv-buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMirrorsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListMirrorsRequest) Execute() (*JSMirrorInfoListResponse, *http.Response, error) {
	return r.ApiService.ListMirrorsExecute(r)
}

/*
ListMirrors List Mirrors

List Mirrors

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListMirrorsRequest
*/
func (a *AccountAPIService) ListMirrors(ctx context.Context, accountId string) ApiListMirrorsRequest {
	return ApiListMirrorsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JSMirrorInfoListResponse
func (a *AccountAPIService) ListMirrorsExecute(r ApiListMirrorsRequest) (*JSMirrorInfoListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JSMirrorInfoListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListMirrors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/jetstream/mirrors"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListObjectBucketsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListObjectBucketsRequest) Execute() (*JSObjectBucketListResponse, *http.Response, error) {
	return r.ApiService.ListObjectBucketsExecute(r)
}

/*
ListObjectBuckets List Object buckets

List Object buckets

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListObjectBucketsRequest
*/
func (a *AccountAPIService) ListObjectBuckets(ctx context.Context, accountId string) ApiListObjectBucketsRequest {
	return ApiListObjectBucketsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JSObjectBucketListResponse
func (a *AccountAPIService) ListObjectBucketsExecute(r ApiListObjectBucketsRequest) (*JSObjectBucketListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JSObjectBucketListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListObjectBuckets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/jetstream/object-buckets"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStreamExportsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListStreamExportsRequest) Execute() (*StreamExportListResponse, *http.Response, error) {
	return r.ApiService.ListStreamExportsExecute(r)
}

/*
ListStreamExports List Stream Exports

List Stream Exports

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListStreamExportsRequest
*/
func (a *AccountAPIService) ListStreamExports(ctx context.Context, accountId string) ApiListStreamExportsRequest {
	return ApiListStreamExportsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return StreamExportListResponse
func (a *AccountAPIService) ListStreamExportsExecute(r ApiListStreamExportsRequest) (*StreamExportListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StreamExportListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListStreamExports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/stream-exports"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStreamExportsSharedRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListStreamExportsSharedRequest) Execute() (*StreamExportSharedListResponse, *http.Response, error) {
	return r.ApiService.ListStreamExportsSharedExecute(r)
}

/*
ListStreamExportsShared List Shared Stream Exports

List stream exports shared with this account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListStreamExportsSharedRequest
*/
func (a *AccountAPIService) ListStreamExportsShared(ctx context.Context, accountId string) ApiListStreamExportsSharedRequest {
	return ApiListStreamExportsSharedRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return StreamExportSharedListResponse
func (a *AccountAPIService) ListStreamExportsSharedExecute(r ApiListStreamExportsSharedRequest) (*StreamExportSharedListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StreamExportSharedListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListStreamExportsShared")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/stream-imports/shared"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStreamImportsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListStreamImportsRequest) Execute() (*StreamImportListResponse, *http.Response, error) {
	return r.ApiService.ListStreamImportsExecute(r)
}

/*
ListStreamImports List Stream Imports

List Stream Imports

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListStreamImportsRequest
*/
func (a *AccountAPIService) ListStreamImports(ctx context.Context, accountId string) ApiListStreamImportsRequest {
	return ApiListStreamImportsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return StreamImportListResponse
func (a *AccountAPIService) ListStreamImportsExecute(r ApiListStreamImportsRequest) (*StreamImportListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *StreamImportListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListStreamImports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/stream-imports"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStreamsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListStreamsRequest) Execute() (*JSStreamInfoListResponse, *http.Response, error) {
	return r.ApiService.ListStreamsExecute(r)
}

/*
ListStreams List Streams

List Streams

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListStreamsRequest
*/
func (a *AccountAPIService) ListStreams(ctx context.Context, accountId string) ApiListStreamsRequest {
	return ApiListStreamsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return JSStreamInfoListResponse
func (a *AccountAPIService) ListStreamsExecute(r ApiListStreamsRequest) (*JSStreamInfoListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *JSStreamInfoListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListStreams")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/jetstream/streams"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSubjectExportsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListSubjectExportsRequest) Execute() (*SubjectExportListResponse, *http.Response, error) {
	return r.ApiService.ListSubjectExportsExecute(r)
}

/*
ListSubjectExports List Subject Exports

List Subject Exports

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListSubjectExportsRequest
*/
func (a *AccountAPIService) ListSubjectExports(ctx context.Context, accountId string) ApiListSubjectExportsRequest {
	return ApiListSubjectExportsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return SubjectExportListResponse
func (a *AccountAPIService) ListSubjectExportsExecute(r ApiListSubjectExportsRequest) (*SubjectExportListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubjectExportListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListSubjectExports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/subject-exports"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSubjectExportsSharedRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListSubjectExportsSharedRequest) Execute() (*SubjectExportSharedListResponse, *http.Response, error) {
	return r.ApiService.ListSubjectExportsSharedExecute(r)
}

/*
ListSubjectExportsShared List Shared Subject Exports

List subject exports shared with this account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListSubjectExportsSharedRequest
*/
func (a *AccountAPIService) ListSubjectExportsShared(ctx context.Context, accountId string) ApiListSubjectExportsSharedRequest {
	return ApiListSubjectExportsSharedRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return SubjectExportSharedListResponse
func (a *AccountAPIService) ListSubjectExportsSharedExecute(r ApiListSubjectExportsSharedRequest) (*SubjectExportSharedListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubjectExportSharedListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListSubjectExportsShared")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/subject-imports/shared"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSubjectImportsRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListSubjectImportsRequest) Execute() (*SubjectImportListResponse, *http.Response, error) {
	return r.ApiService.ListSubjectImportsExecute(r)
}

/*
ListSubjectImports List Subject Imports

List Subject Imports

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListSubjectImportsRequest
*/
func (a *AccountAPIService) ListSubjectImports(ctx context.Context, accountId string) ApiListSubjectImportsRequest {
	return ApiListSubjectImportsRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return SubjectImportListResponse
func (a *AccountAPIService) ListSubjectImportsExecute(r ApiListSubjectImportsRequest) (*SubjectImportListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubjectImportListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListSubjectImports")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/subject-imports"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsersRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiListUsersRequest) Execute() (*NatsUserListResponse, *http.Response, error) {
	return r.ApiService.ListUsersExecute(r)
}

/*
ListUsers List NATS Users

Returns a list of NATS users for the given account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiListUsersRequest
*/
func (a *AccountAPIService) ListUsers(ctx context.Context, accountId string) ApiListUsersRequest {
	return ApiListUsersRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return NatsUserListResponse
func (a *AccountAPIService) ListUsersExecute(r ApiListUsersRequest) (*NatsUserListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.ListUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/nats-users"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunAlertRuleRequest struct {
	ctx         context.Context
	ApiService  AccountAPI
	accountId   string
	alertRuleId string
}

func (r ApiRunAlertRuleRequest) Execute() (*AlertViewResponse, *http.Response, error) {
	return r.ApiService.RunAlertRuleExecute(r)
}

/*
RunAlertRule Run Account Alert Rule

Run Account Alert Rule and return an alert object if the rule condition is met

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@param alertRuleId
	@return ApiRunAlertRuleRequest
*/
func (a *AccountAPIService) RunAlertRule(ctx context.Context, accountId string, alertRuleId string) ApiRunAlertRuleRequest {
	return ApiRunAlertRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		accountId:   accountId,
		alertRuleId: alertRuleId,
	}
}

// Execute executes the request
//
//	@return AlertViewResponse
func (a *AccountAPIService) RunAlertRuleExecute(r ApiRunAlertRuleRequest) (*AlertViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.RunAlertRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/alert-rules/{alertRuleId}/run"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertRuleId"+"}", url.PathEscape(parameterValueToString(r.alertRuleId, "alertRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnAssignAccountTeamAppUserRequest struct {
	ctx           context.Context
	ApiService    AccountAPI
	accountId     string
	teamAppUserId string
}

func (r ApiUnAssignAccountTeamAppUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnAssignAccountTeamAppUserExecute(r)
}

/*
UnAssignAccountTeamAppUser Unassign Team App User from Account

Unassign a Team App User from an Account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@param teamAppUserId
	@return ApiUnAssignAccountTeamAppUserRequest
*/
func (a *AccountAPIService) UnAssignAccountTeamAppUser(ctx context.Context, accountId string, teamAppUserId string) ApiUnAssignAccountTeamAppUserRequest {
	return ApiUnAssignAccountTeamAppUserRequest{
		ApiService:    a,
		ctx:           ctx,
		accountId:     accountId,
		teamAppUserId: teamAppUserId,
	}
}

// Execute executes the request
func (a *AccountAPIService) UnAssignAccountTeamAppUserExecute(r ApiUnAssignAccountTeamAppUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.UnAssignAccountTeamAppUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/app-users/{teamAppUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamAppUserId"+"}", url.PathEscape(parameterValueToString(r.teamAppUserId, "teamAppUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnmanageAccountRequest struct {
	ctx        context.Context
	ApiService AccountAPI
	accountId  string
}

func (r ApiUnmanageAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnmanageAccountExecute(r)
}

/*
UnmanageAccount Unmanage Account

Unmanage a Account in a system

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiUnmanageAccountRequest
*/
func (a *AccountAPIService) UnmanageAccount(ctx context.Context, accountId string) ApiUnmanageAccountRequest {
	return ApiUnmanageAccountRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
func (a *AccountAPIService) UnmanageAccountExecute(r ApiUnmanageAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.UnmanageAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/unmanage"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAccountRequest struct {
	ctx                  context.Context
	ApiService           AccountAPI
	accountId            string
	accountUpdateRequest *AccountUpdateRequest
}

func (r ApiUpdateAccountRequest) AccountUpdateRequest(accountUpdateRequest AccountUpdateRequest) ApiUpdateAccountRequest {
	r.accountUpdateRequest = &accountUpdateRequest
	return r
}

func (r ApiUpdateAccountRequest) Execute() (*AccountViewResponse, *http.Response, error) {
	return r.ApiService.UpdateAccountExecute(r)
}

/*
UpdateAccount Update Account

Updates a Account in a system

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@return ApiUpdateAccountRequest
*/
func (a *AccountAPIService) UpdateAccount(ctx context.Context, accountId string) ApiUpdateAccountRequest {
	return ApiUpdateAccountRequest{
		ApiService: a,
		ctx:        ctx,
		accountId:  accountId,
	}
}

// Execute executes the request
//
//	@return AccountViewResponse
func (a *AccountAPIService) UpdateAccountExecute(r ApiUpdateAccountRequest) (*AccountViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AccountViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.UpdateAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accountUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAlertRuleRequest struct {
	ctx                    context.Context
	ApiService             AccountAPI
	accountId              string
	alertRuleId            string
	alertRuleUpdateRequest *AlertRuleUpdateRequest
}

func (r ApiUpdateAlertRuleRequest) AlertRuleUpdateRequest(alertRuleUpdateRequest AlertRuleUpdateRequest) ApiUpdateAlertRuleRequest {
	r.alertRuleUpdateRequest = &alertRuleUpdateRequest
	return r
}

func (r ApiUpdateAlertRuleRequest) Execute() (*AlertRuleViewResponse, *http.Response, error) {
	return r.ApiService.UpdateAlertRuleExecute(r)
}

/*
UpdateAlertRule Update Account Alert Rule

Update Account Alert Rule

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountId
	@param alertRuleId
	@return ApiUpdateAlertRuleRequest
*/
func (a *AccountAPIService) UpdateAlertRule(ctx context.Context, accountId string, alertRuleId string) ApiUpdateAlertRuleRequest {
	return ApiUpdateAlertRuleRequest{
		ApiService:  a,
		ctx:         ctx,
		accountId:   accountId,
		alertRuleId: alertRuleId,
	}
}

// Execute executes the request
//
//	@return AlertRuleViewResponse
func (a *AccountAPIService) UpdateAlertRuleExecute(r ApiUpdateAlertRuleRequest) (*AlertRuleViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertRuleViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountAPIService.UpdateAlertRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/accounts/{accountId}/alert-rules/{alertRuleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertRuleId"+"}", url.PathEscape(parameterValueToString(r.alertRuleId, "alertRuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.alertRuleUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
