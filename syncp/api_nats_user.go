/*
Synadia Control Plane

API for Synadia Control Plane Server

API version: beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package syncp

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type NatsUserAPI interface {

	/*
		AssignNatsUserTeamAppUser Assign Team App User to NATS User

		Assign a Team App User to a NATS User. This operation is idempotent; if an App User is already assigned to a NATS User the assignment will be updated with the new role

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@param teamAppUserId
		@return ApiAssignNatsUserTeamAppUserRequest
	*/
	AssignNatsUserTeamAppUser(ctx context.Context, userId string, teamAppUserId string) ApiAssignNatsUserTeamAppUserRequest

	// AssignNatsUserTeamAppUserExecute executes the request
	//  @return AppUserAssignResponse
	AssignNatsUserTeamAppUserExecute(r ApiAssignNatsUserTeamAppUserRequest) (*AppUserAssignResponse, *http.Response, error)

	/*
		CopyNatsUser Copy nats user

		Copies the user, changing name and account SK group. Generates new user NKey

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@return ApiCopyNatsUserRequest
	*/
	CopyNatsUser(ctx context.Context, userId string) ApiCopyNatsUserRequest

	// CopyNatsUserExecute executes the request
	//  @return NatsUserViewResponse
	CopyNatsUserExecute(r ApiCopyNatsUserRequest) (*NatsUserViewResponse, *http.Response, error)

	/*
		DeleteNatsUser Delete NATS User

		Deletes a NATS user from an account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@return ApiDeleteNatsUserRequest
	*/
	DeleteNatsUser(ctx context.Context, userId string) ApiDeleteNatsUserRequest

	// DeleteNatsUserExecute executes the request
	DeleteNatsUserExecute(r ApiDeleteNatsUserRequest) (*http.Response, error)

	/*
		DownloadNatsUserCreds Get Creds

		Returns a creds file for a NATS user assigned to the account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@return ApiDownloadNatsUserCredsRequest
	*/
	DownloadNatsUserCreds(ctx context.Context, userId string) ApiDownloadNatsUserCredsRequest

	// DownloadNatsUserCredsExecute executes the request
	//  @return string
	DownloadNatsUserCredsExecute(r ApiDownloadNatsUserCredsRequest) (string, *http.Response, error)

	/*
		GetNatsUser Get NATS User

		Returns a NATS user assigned to the account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@return ApiGetNatsUserRequest
	*/
	GetNatsUser(ctx context.Context, userId string) ApiGetNatsUserRequest

	// GetNatsUserExecute executes the request
	//  @return NatsUserViewResponse
	GetNatsUserExecute(r ApiGetNatsUserRequest) (*NatsUserViewResponse, *http.Response, error)

	/*
		ListNatsUserConnections List NATs User Connections

		List NATs User Connections

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@return ApiListNatsUserConnectionsRequest
	*/
	ListNatsUserConnections(ctx context.Context, userId string) ApiListNatsUserConnectionsRequest

	// ListNatsUserConnectionsExecute executes the request
	//  @return NatsUserConnectionsListResponse
	ListNatsUserConnectionsExecute(r ApiListNatsUserConnectionsRequest) (*NatsUserConnectionsListResponse, *http.Response, error)

	/*
		ListNatsUserIssuances List nats user issuances

		Lists the history of user credential issuances for the user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@return ApiListNatsUserIssuancesRequest
	*/
	ListNatsUserIssuances(ctx context.Context, userId string) ApiListNatsUserIssuancesRequest

	// ListNatsUserIssuancesExecute executes the request
	//  @return NatsUserIssuancesListResponse
	ListNatsUserIssuancesExecute(r ApiListNatsUserIssuancesRequest) (*NatsUserIssuancesListResponse, *http.Response, error)

	/*
		ListNatsUserTeamAppUsers List Team App Users

		Returns a list of Team App Users associated with the NATS user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@return ApiListNatsUserTeamAppUsersRequest
	*/
	ListNatsUserTeamAppUsers(ctx context.Context, userId string) ApiListNatsUserTeamAppUsersRequest

	// ListNatsUserTeamAppUsersExecute executes the request
	//  @return AppUserAssignListResponse
	ListNatsUserTeamAppUsersExecute(r ApiListNatsUserTeamAppUsersRequest) (*AppUserAssignListResponse, *http.Response, error)

	/*
		RotateNatsUser Rotate nats user nkey and seed

		Generates new user nkey

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@return ApiRotateNatsUserRequest
	*/
	RotateNatsUser(ctx context.Context, userId string) ApiRotateNatsUserRequest

	// RotateNatsUserExecute executes the request
	//  @return NatsUserViewResponse
	RotateNatsUserExecute(r ApiRotateNatsUserRequest) (*NatsUserViewResponse, *http.Response, error)

	/*
		UnAssignNatsUserTeamAppUser Unassign Team App User from NATS User

		Unassign a Team App User from a NATS User

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@param teamAppUserId
		@return ApiUnAssignNatsUserTeamAppUserRequest
	*/
	UnAssignNatsUserTeamAppUser(ctx context.Context, userId string, teamAppUserId string) ApiUnAssignNatsUserTeamAppUserRequest

	// UnAssignNatsUserTeamAppUserExecute executes the request
	UnAssignNatsUserTeamAppUserExecute(r ApiUnAssignNatsUserTeamAppUserRequest) (*http.Response, error)

	/*
		UpdateNatsUser Update NATS User

		Updates NATS User in an account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param userId
		@return ApiUpdateNatsUserRequest
	*/
	UpdateNatsUser(ctx context.Context, userId string) ApiUpdateNatsUserRequest

	// UpdateNatsUserExecute executes the request
	//  @return NatsUserViewResponse
	UpdateNatsUserExecute(r ApiUpdateNatsUserRequest) (*NatsUserViewResponse, *http.Response, error)
}

// NatsUserAPIService NatsUserAPI service
type NatsUserAPIService service

type ApiAssignNatsUserTeamAppUserRequest struct {
	ctx                  context.Context
	ApiService           NatsUserAPI
	userId               string
	teamAppUserId        string
	appUserAssignRequest *AppUserAssignRequest
}

func (r ApiAssignNatsUserTeamAppUserRequest) AppUserAssignRequest(appUserAssignRequest AppUserAssignRequest) ApiAssignNatsUserTeamAppUserRequest {
	r.appUserAssignRequest = &appUserAssignRequest
	return r
}

func (r ApiAssignNatsUserTeamAppUserRequest) Execute() (*AppUserAssignResponse, *http.Response, error) {
	return r.ApiService.AssignNatsUserTeamAppUserExecute(r)
}

/*
AssignNatsUserTeamAppUser Assign Team App User to NATS User

Assign a Team App User to a NATS User. This operation is idempotent; if an App User is already assigned to a NATS User the assignment will be updated with the new role

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@param teamAppUserId
	@return ApiAssignNatsUserTeamAppUserRequest
*/
func (a *NatsUserAPIService) AssignNatsUserTeamAppUser(ctx context.Context, userId string, teamAppUserId string) ApiAssignNatsUserTeamAppUserRequest {
	return ApiAssignNatsUserTeamAppUserRequest{
		ApiService:    a,
		ctx:           ctx,
		userId:        userId,
		teamAppUserId: teamAppUserId,
	}
}

// Execute executes the request
//
//	@return AppUserAssignResponse
func (a *NatsUserAPIService) AssignNatsUserTeamAppUserExecute(r ApiAssignNatsUserTeamAppUserRequest) (*AppUserAssignResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppUserAssignResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.AssignNatsUserTeamAppUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}/app-users/{teamAppUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamAppUserId"+"}", url.PathEscape(parameterValueToString(r.teamAppUserId, "teamAppUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appUserAssignRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCopyNatsUserRequest struct {
	ctx                 context.Context
	ApiService          NatsUserAPI
	userId              string
	natsUserCopyRequest *NatsUserCopyRequest
}

func (r ApiCopyNatsUserRequest) NatsUserCopyRequest(natsUserCopyRequest NatsUserCopyRequest) ApiCopyNatsUserRequest {
	r.natsUserCopyRequest = &natsUserCopyRequest
	return r
}

func (r ApiCopyNatsUserRequest) Execute() (*NatsUserViewResponse, *http.Response, error) {
	return r.ApiService.CopyNatsUserExecute(r)
}

/*
CopyNatsUser Copy nats user

Copies the user, changing name and account SK group. Generates new user NKey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiCopyNatsUserRequest
*/
func (a *NatsUserAPIService) CopyNatsUser(ctx context.Context, userId string) ApiCopyNatsUserRequest {
	return ApiCopyNatsUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return NatsUserViewResponse
func (a *NatsUserAPIService) CopyNatsUserExecute(r ApiCopyNatsUserRequest) (*NatsUserViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.CopyNatsUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.natsUserCopyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNatsUserRequest struct {
	ctx        context.Context
	ApiService NatsUserAPI
	userId     string
}

func (r ApiDeleteNatsUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNatsUserExecute(r)
}

/*
DeleteNatsUser Delete NATS User

Deletes a NATS user from an account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiDeleteNatsUserRequest
*/
func (a *NatsUserAPIService) DeleteNatsUser(ctx context.Context, userId string) ApiDeleteNatsUserRequest {
	return ApiDeleteNatsUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
func (a *NatsUserAPIService) DeleteNatsUserExecute(r ApiDeleteNatsUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.DeleteNatsUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadNatsUserCredsRequest struct {
	ctx        context.Context
	ApiService NatsUserAPI
	userId     string
}

func (r ApiDownloadNatsUserCredsRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DownloadNatsUserCredsExecute(r)
}

/*
DownloadNatsUserCreds Get Creds

Returns a creds file for a NATS user assigned to the account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiDownloadNatsUserCredsRequest
*/
func (a *NatsUserAPIService) DownloadNatsUserCreds(ctx context.Context, userId string) ApiDownloadNatsUserCredsRequest {
	return ApiDownloadNatsUserCredsRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return string
func (a *NatsUserAPIService) DownloadNatsUserCredsExecute(r ApiDownloadNatsUserCredsRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.DownloadNatsUserCreds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}/creds"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNatsUserRequest struct {
	ctx        context.Context
	ApiService NatsUserAPI
	userId     string
}

func (r ApiGetNatsUserRequest) Execute() (*NatsUserViewResponse, *http.Response, error) {
	return r.ApiService.GetNatsUserExecute(r)
}

/*
GetNatsUser Get NATS User

Returns a NATS user assigned to the account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiGetNatsUserRequest
*/
func (a *NatsUserAPIService) GetNatsUser(ctx context.Context, userId string) ApiGetNatsUserRequest {
	return ApiGetNatsUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return NatsUserViewResponse
func (a *NatsUserAPIService) GetNatsUserExecute(r ApiGetNatsUserRequest) (*NatsUserViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.GetNatsUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNatsUserConnectionsRequest struct {
	ctx        context.Context
	ApiService NatsUserAPI
	userId     string
	sort       *string
	cid        *string
	state      *string
	subject    *string
	limit      *float32
}

func (r ApiListNatsUserConnectionsRequest) Sort(sort string) ApiListNatsUserConnectionsRequest {
	r.sort = &sort
	return r
}

func (r ApiListNatsUserConnectionsRequest) Cid(cid string) ApiListNatsUserConnectionsRequest {
	r.cid = &cid
	return r
}

func (r ApiListNatsUserConnectionsRequest) State(state string) ApiListNatsUserConnectionsRequest {
	r.state = &state
	return r
}

func (r ApiListNatsUserConnectionsRequest) Subject(subject string) ApiListNatsUserConnectionsRequest {
	r.subject = &subject
	return r
}

func (r ApiListNatsUserConnectionsRequest) Limit(limit float32) ApiListNatsUserConnectionsRequest {
	r.limit = &limit
	return r
}

func (r ApiListNatsUserConnectionsRequest) Execute() (*NatsUserConnectionsListResponse, *http.Response, error) {
	return r.ApiService.ListNatsUserConnectionsExecute(r)
}

/*
ListNatsUserConnections List NATs User Connections

List NATs User Connections

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiListNatsUserConnectionsRequest
*/
func (a *NatsUserAPIService) ListNatsUserConnections(ctx context.Context, userId string) ApiListNatsUserConnectionsRequest {
	return ApiListNatsUserConnectionsRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return NatsUserConnectionsListResponse
func (a *NatsUserAPIService) ListNatsUserConnectionsExecute(r ApiListNatsUserConnectionsRequest) (*NatsUserConnectionsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserConnectionsListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.ListNatsUserConnections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}/connections"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.cid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cid", r.cid, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.subject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subject", r.subject, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNatsUserIssuancesRequest struct {
	ctx        context.Context
	ApiService NatsUserAPI
	userId     string
}

func (r ApiListNatsUserIssuancesRequest) Execute() (*NatsUserIssuancesListResponse, *http.Response, error) {
	return r.ApiService.ListNatsUserIssuancesExecute(r)
}

/*
ListNatsUserIssuances List nats user issuances

Lists the history of user credential issuances for the user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiListNatsUserIssuancesRequest
*/
func (a *NatsUserAPIService) ListNatsUserIssuances(ctx context.Context, userId string) ApiListNatsUserIssuancesRequest {
	return ApiListNatsUserIssuancesRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return NatsUserIssuancesListResponse
func (a *NatsUserAPIService) ListNatsUserIssuancesExecute(r ApiListNatsUserIssuancesRequest) (*NatsUserIssuancesListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserIssuancesListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.ListNatsUserIssuances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}/issuances"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNatsUserTeamAppUsersRequest struct {
	ctx        context.Context
	ApiService NatsUserAPI
	userId     string
}

func (r ApiListNatsUserTeamAppUsersRequest) Execute() (*AppUserAssignListResponse, *http.Response, error) {
	return r.ApiService.ListNatsUserTeamAppUsersExecute(r)
}

/*
ListNatsUserTeamAppUsers List Team App Users

Returns a list of Team App Users associated with the NATS user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiListNatsUserTeamAppUsersRequest
*/
func (a *NatsUserAPIService) ListNatsUserTeamAppUsers(ctx context.Context, userId string) ApiListNatsUserTeamAppUsersRequest {
	return ApiListNatsUserTeamAppUsersRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return AppUserAssignListResponse
func (a *NatsUserAPIService) ListNatsUserTeamAppUsersExecute(r ApiListNatsUserTeamAppUsersRequest) (*AppUserAssignListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AppUserAssignListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.ListNatsUserTeamAppUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}/app-users"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotateNatsUserRequest struct {
	ctx        context.Context
	ApiService NatsUserAPI
	userId     string
}

func (r ApiRotateNatsUserRequest) Execute() (*NatsUserViewResponse, *http.Response, error) {
	return r.ApiService.RotateNatsUserExecute(r)
}

/*
RotateNatsUser Rotate nats user nkey and seed

Generates new user nkey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiRotateNatsUserRequest
*/
func (a *NatsUserAPIService) RotateNatsUser(ctx context.Context, userId string) ApiRotateNatsUserRequest {
	return ApiRotateNatsUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return NatsUserViewResponse
func (a *NatsUserAPIService) RotateNatsUserExecute(r ApiRotateNatsUserRequest) (*NatsUserViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.RotateNatsUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}/rotate"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnAssignNatsUserTeamAppUserRequest struct {
	ctx           context.Context
	ApiService    NatsUserAPI
	userId        string
	teamAppUserId string
}

func (r ApiUnAssignNatsUserTeamAppUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnAssignNatsUserTeamAppUserExecute(r)
}

/*
UnAssignNatsUserTeamAppUser Unassign Team App User from NATS User

Unassign a Team App User from a NATS User

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@param teamAppUserId
	@return ApiUnAssignNatsUserTeamAppUserRequest
*/
func (a *NatsUserAPIService) UnAssignNatsUserTeamAppUser(ctx context.Context, userId string, teamAppUserId string) ApiUnAssignNatsUserTeamAppUserRequest {
	return ApiUnAssignNatsUserTeamAppUserRequest{
		ApiService:    a,
		ctx:           ctx,
		userId:        userId,
		teamAppUserId: teamAppUserId,
	}
}

// Execute executes the request
func (a *NatsUserAPIService) UnAssignNatsUserTeamAppUserExecute(r ApiUnAssignNatsUserTeamAppUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.UnAssignNatsUserTeamAppUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}/app-users/{teamAppUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamAppUserId"+"}", url.PathEscape(parameterValueToString(r.teamAppUserId, "teamAppUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateNatsUserRequest struct {
	ctx                   context.Context
	ApiService            NatsUserAPI
	userId                string
	natsUserUpdateRequest *NatsUserUpdateRequest
}

func (r ApiUpdateNatsUserRequest) NatsUserUpdateRequest(natsUserUpdateRequest NatsUserUpdateRequest) ApiUpdateNatsUserRequest {
	r.natsUserUpdateRequest = &natsUserUpdateRequest
	return r
}

func (r ApiUpdateNatsUserRequest) Execute() (*NatsUserViewResponse, *http.Response, error) {
	return r.ApiService.UpdateNatsUserExecute(r)
}

/*
UpdateNatsUser Update NATS User

Updates NATS User in an account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param userId
	@return ApiUpdateNatsUserRequest
*/
func (a *NatsUserAPIService) UpdateNatsUser(ctx context.Context, userId string) ApiUpdateNatsUserRequest {
	return ApiUpdateNatsUserRequest{
		ApiService: a,
		ctx:        ctx,
		userId:     userId,
	}
}

// Execute executes the request
//
//	@return NatsUserViewResponse
func (a *NatsUserAPIService) UpdateNatsUserExecute(r ApiUpdateNatsUserRequest) (*NatsUserViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *NatsUserViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NatsUserAPIService.UpdateNatsUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nats-users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.natsUserUpdateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
