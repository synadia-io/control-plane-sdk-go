/*
Synadia Control Plane / Synadia Cloud

API for Synadia Control Plane / Synadia Cloud

API version: beta
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package syncp

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type AuthCalloutAPI interface {

	/*
		AddAuthCalloutTargetAccount Configure Target Account

		Configure a target account

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param authCalloutId
		@return ApiAddAuthCalloutTargetAccountRequest
	*/
	AddAuthCalloutTargetAccount(ctx context.Context, authCalloutId string) ApiAddAuthCalloutTargetAccountRequest

	// AddAuthCalloutTargetAccountExecute executes the request
	AddAuthCalloutTargetAccountExecute(r ApiAddAuthCalloutTargetAccountRequest) (*http.Response, error)

	/*
		AddAuthCalloutUser Create Auth Callout User

		Create a Control Account User that can access auth callout

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param authCalloutId
		@return ApiAddAuthCalloutUserRequest
	*/
	AddAuthCalloutUser(ctx context.Context, authCalloutId string) ApiAddAuthCalloutUserRequest

	// AddAuthCalloutUserExecute executes the request
	AddAuthCalloutUserExecute(r ApiAddAuthCalloutUserRequest) (*http.Response, error)

	/*
		DeleteAuthCallout Delete Auth Callout Config

		Remove auth callout config and update the control account jwt

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param authCalloutId
		@return ApiDeleteAuthCalloutRequest
	*/
	DeleteAuthCallout(ctx context.Context, authCalloutId string) ApiDeleteAuthCalloutRequest

	// DeleteAuthCalloutExecute executes the request
	DeleteAuthCalloutExecute(r ApiDeleteAuthCalloutRequest) (*http.Response, error)

	/*
		DeleteAuthCalloutTargetAccount Delete Target Account

		Remove configured target account entry

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param authCalloutId
		@param targetAccountId
		@return ApiDeleteAuthCalloutTargetAccountRequest
	*/
	DeleteAuthCalloutTargetAccount(ctx context.Context, authCalloutId string, targetAccountId string) ApiDeleteAuthCalloutTargetAccountRequest

	// DeleteAuthCalloutTargetAccountExecute executes the request
	DeleteAuthCalloutTargetAccountExecute(r ApiDeleteAuthCalloutTargetAccountRequest) (*http.Response, error)

	/*
		DeleteAuthCalloutUser Delete Control Account User

		Remove control account auth callout user

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param authCalloutId
		@param acUserId
		@return ApiDeleteAuthCalloutUserRequest
	*/
	DeleteAuthCalloutUser(ctx context.Context, authCalloutId string, acUserId string) ApiDeleteAuthCalloutUserRequest

	// DeleteAuthCalloutUserExecute executes the request
	DeleteAuthCalloutUserExecute(r ApiDeleteAuthCalloutUserRequest) (*http.Response, error)

	/*
		GetAuthCallout Auth Callout Config

		Returns the Auth Callout Config

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param authCalloutId
		@return ApiGetAuthCalloutRequest
	*/
	GetAuthCallout(ctx context.Context, authCalloutId string) ApiGetAuthCalloutRequest

	// GetAuthCalloutExecute executes the request
	//  @return AuthCalloutViewResponse
	GetAuthCalloutExecute(r ApiGetAuthCalloutRequest) (*AuthCalloutViewResponse, *http.Response, error)

	/*
		ListAuthCalloutTargetAccounts Get Target Account List

		Get a list of configured Target Accounts

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param authCalloutId
		@return ApiListAuthCalloutTargetAccountsRequest
	*/
	ListAuthCalloutTargetAccounts(ctx context.Context, authCalloutId string) ApiListAuthCalloutTargetAccountsRequest

	// ListAuthCalloutTargetAccountsExecute executes the request
	//  @return AuthCalloutTargetAccountListResponse
	ListAuthCalloutTargetAccountsExecute(r ApiListAuthCalloutTargetAccountsRequest) (*AuthCalloutTargetAccountListResponse, *http.Response, error)

	/*
		ListAuthCalloutUsers Get Target Account List

		Get a list of configured Target Accounts

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param authCalloutId
		@return ApiListAuthCalloutUsersRequest
	*/
	ListAuthCalloutUsers(ctx context.Context, authCalloutId string) ApiListAuthCalloutUsersRequest

	// ListAuthCalloutUsersExecute executes the request
	//  @return AuthCalloutUsersListResponse
	ListAuthCalloutUsersExecute(r ApiListAuthCalloutUsersRequest) (*AuthCalloutUsersListResponse, *http.Response, error)
}

// AuthCalloutAPIService AuthCalloutAPI service
type AuthCalloutAPIService service

type ApiAddAuthCalloutTargetAccountRequest struct {
	ctx                                context.Context
	ApiService                         AuthCalloutAPI
	authCalloutId                      string
	authCalloutAddTargetAccountRequest *AuthCalloutAddTargetAccountRequest
}

func (r ApiAddAuthCalloutTargetAccountRequest) AuthCalloutAddTargetAccountRequest(authCalloutAddTargetAccountRequest AuthCalloutAddTargetAccountRequest) ApiAddAuthCalloutTargetAccountRequest {
	r.authCalloutAddTargetAccountRequest = &authCalloutAddTargetAccountRequest
	return r
}

func (r ApiAddAuthCalloutTargetAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddAuthCalloutTargetAccountExecute(r)
}

/*
AddAuthCalloutTargetAccount Configure Target Account

Configure a target account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param authCalloutId
	@return ApiAddAuthCalloutTargetAccountRequest
*/
func (a *AuthCalloutAPIService) AddAuthCalloutTargetAccount(ctx context.Context, authCalloutId string) ApiAddAuthCalloutTargetAccountRequest {
	return ApiAddAuthCalloutTargetAccountRequest{
		ApiService:    a,
		ctx:           ctx,
		authCalloutId: authCalloutId,
	}
}

// Execute executes the request
func (a *AuthCalloutAPIService) AddAuthCalloutTargetAccountExecute(r ApiAddAuthCalloutTargetAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthCalloutAPIService.AddAuthCalloutTargetAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/beta/auth-callout/{authCalloutId}/target-accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"authCalloutId"+"}", url.PathEscape(parameterValueToString(r.authCalloutId, "authCalloutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authCalloutAddTargetAccountRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAddAuthCalloutUserRequest struct {
	ctx                       context.Context
	ApiService                AuthCalloutAPI
	authCalloutId             string
	authCalloutAddUserRequest *AuthCalloutAddUserRequest
}

func (r ApiAddAuthCalloutUserRequest) AuthCalloutAddUserRequest(authCalloutAddUserRequest AuthCalloutAddUserRequest) ApiAddAuthCalloutUserRequest {
	r.authCalloutAddUserRequest = &authCalloutAddUserRequest
	return r
}

func (r ApiAddAuthCalloutUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddAuthCalloutUserExecute(r)
}

/*
AddAuthCalloutUser Create Auth Callout User

Create a Control Account User that can access auth callout

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param authCalloutId
	@return ApiAddAuthCalloutUserRequest
*/
func (a *AuthCalloutAPIService) AddAuthCalloutUser(ctx context.Context, authCalloutId string) ApiAddAuthCalloutUserRequest {
	return ApiAddAuthCalloutUserRequest{
		ApiService:    a,
		ctx:           ctx,
		authCalloutId: authCalloutId,
	}
}

// Execute executes the request
func (a *AuthCalloutAPIService) AddAuthCalloutUserExecute(r ApiAddAuthCalloutUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthCalloutAPIService.AddAuthCalloutUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/beta/auth-callout/{authCalloutId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"authCalloutId"+"}", url.PathEscape(parameterValueToString(r.authCalloutId, "authCalloutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authCalloutAddUserRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAuthCalloutRequest struct {
	ctx           context.Context
	ApiService    AuthCalloutAPI
	authCalloutId string
}

func (r ApiDeleteAuthCalloutRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAuthCalloutExecute(r)
}

/*
DeleteAuthCallout Delete Auth Callout Config

Remove auth callout config and update the control account jwt

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param authCalloutId
	@return ApiDeleteAuthCalloutRequest
*/
func (a *AuthCalloutAPIService) DeleteAuthCallout(ctx context.Context, authCalloutId string) ApiDeleteAuthCalloutRequest {
	return ApiDeleteAuthCalloutRequest{
		ApiService:    a,
		ctx:           ctx,
		authCalloutId: authCalloutId,
	}
}

// Execute executes the request
func (a *AuthCalloutAPIService) DeleteAuthCalloutExecute(r ApiDeleteAuthCalloutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthCalloutAPIService.DeleteAuthCallout")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/beta/auth-callout/{authCalloutId}"
	localVarPath = strings.Replace(localVarPath, "{"+"authCalloutId"+"}", url.PathEscape(parameterValueToString(r.authCalloutId, "authCalloutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAuthCalloutTargetAccountRequest struct {
	ctx             context.Context
	ApiService      AuthCalloutAPI
	authCalloutId   string
	targetAccountId string
}

func (r ApiDeleteAuthCalloutTargetAccountRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAuthCalloutTargetAccountExecute(r)
}

/*
DeleteAuthCalloutTargetAccount Delete Target Account

Remove configured target account entry

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param authCalloutId
	@param targetAccountId
	@return ApiDeleteAuthCalloutTargetAccountRequest
*/
func (a *AuthCalloutAPIService) DeleteAuthCalloutTargetAccount(ctx context.Context, authCalloutId string, targetAccountId string) ApiDeleteAuthCalloutTargetAccountRequest {
	return ApiDeleteAuthCalloutTargetAccountRequest{
		ApiService:      a,
		ctx:             ctx,
		authCalloutId:   authCalloutId,
		targetAccountId: targetAccountId,
	}
}

// Execute executes the request
func (a *AuthCalloutAPIService) DeleteAuthCalloutTargetAccountExecute(r ApiDeleteAuthCalloutTargetAccountRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthCalloutAPIService.DeleteAuthCalloutTargetAccount")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/beta/auth-callout/{authCalloutId}/target-accounts/{targetAccountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"authCalloutId"+"}", url.PathEscape(parameterValueToString(r.authCalloutId, "authCalloutId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"targetAccountId"+"}", url.PathEscape(parameterValueToString(r.targetAccountId, "targetAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteAuthCalloutUserRequest struct {
	ctx           context.Context
	ApiService    AuthCalloutAPI
	authCalloutId string
	acUserId      string
}

func (r ApiDeleteAuthCalloutUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAuthCalloutUserExecute(r)
}

/*
DeleteAuthCalloutUser Delete Control Account User

Remove control account auth callout user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param authCalloutId
	@param acUserId
	@return ApiDeleteAuthCalloutUserRequest
*/
func (a *AuthCalloutAPIService) DeleteAuthCalloutUser(ctx context.Context, authCalloutId string, acUserId string) ApiDeleteAuthCalloutUserRequest {
	return ApiDeleteAuthCalloutUserRequest{
		ApiService:    a,
		ctx:           ctx,
		authCalloutId: authCalloutId,
		acUserId:      acUserId,
	}
}

// Execute executes the request
func (a *AuthCalloutAPIService) DeleteAuthCalloutUserExecute(r ApiDeleteAuthCalloutUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthCalloutAPIService.DeleteAuthCalloutUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/beta/auth-callout/{authCalloutId}/users/{acUserId}"
	localVarPath = strings.Replace(localVarPath, "{"+"authCalloutId"+"}", url.PathEscape(parameterValueToString(r.authCalloutId, "authCalloutId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acUserId"+"}", url.PathEscape(parameterValueToString(r.acUserId, "acUserId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAuthCalloutRequest struct {
	ctx           context.Context
	ApiService    AuthCalloutAPI
	authCalloutId string
}

func (r ApiGetAuthCalloutRequest) Execute() (*AuthCalloutViewResponse, *http.Response, error) {
	return r.ApiService.GetAuthCalloutExecute(r)
}

/*
GetAuthCallout Auth Callout Config

Returns the Auth Callout Config

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param authCalloutId
	@return ApiGetAuthCalloutRequest
*/
func (a *AuthCalloutAPIService) GetAuthCallout(ctx context.Context, authCalloutId string) ApiGetAuthCalloutRequest {
	return ApiGetAuthCalloutRequest{
		ApiService:    a,
		ctx:           ctx,
		authCalloutId: authCalloutId,
	}
}

// Execute executes the request
//
//	@return AuthCalloutViewResponse
func (a *AuthCalloutAPIService) GetAuthCalloutExecute(r ApiGetAuthCalloutRequest) (*AuthCalloutViewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthCalloutViewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthCalloutAPIService.GetAuthCallout")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/beta/auth-callout/{authCalloutId}"
	localVarPath = strings.Replace(localVarPath, "{"+"authCalloutId"+"}", url.PathEscape(parameterValueToString(r.authCalloutId, "authCalloutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuthCalloutTargetAccountsRequest struct {
	ctx           context.Context
	ApiService    AuthCalloutAPI
	authCalloutId string
}

func (r ApiListAuthCalloutTargetAccountsRequest) Execute() (*AuthCalloutTargetAccountListResponse, *http.Response, error) {
	return r.ApiService.ListAuthCalloutTargetAccountsExecute(r)
}

/*
ListAuthCalloutTargetAccounts Get Target Account List

Get a list of configured Target Accounts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param authCalloutId
	@return ApiListAuthCalloutTargetAccountsRequest
*/
func (a *AuthCalloutAPIService) ListAuthCalloutTargetAccounts(ctx context.Context, authCalloutId string) ApiListAuthCalloutTargetAccountsRequest {
	return ApiListAuthCalloutTargetAccountsRequest{
		ApiService:    a,
		ctx:           ctx,
		authCalloutId: authCalloutId,
	}
}

// Execute executes the request
//
//	@return AuthCalloutTargetAccountListResponse
func (a *AuthCalloutAPIService) ListAuthCalloutTargetAccountsExecute(r ApiListAuthCalloutTargetAccountsRequest) (*AuthCalloutTargetAccountListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthCalloutTargetAccountListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthCalloutAPIService.ListAuthCalloutTargetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/beta/auth-callout/{authCalloutId}/target-accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"authCalloutId"+"}", url.PathEscape(parameterValueToString(r.authCalloutId, "authCalloutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAuthCalloutUsersRequest struct {
	ctx           context.Context
	ApiService    AuthCalloutAPI
	authCalloutId string
}

func (r ApiListAuthCalloutUsersRequest) Execute() (*AuthCalloutUsersListResponse, *http.Response, error) {
	return r.ApiService.ListAuthCalloutUsersExecute(r)
}

/*
ListAuthCalloutUsers Get Target Account List

Get a list of configured Target Accounts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param authCalloutId
	@return ApiListAuthCalloutUsersRequest
*/
func (a *AuthCalloutAPIService) ListAuthCalloutUsers(ctx context.Context, authCalloutId string) ApiListAuthCalloutUsersRequest {
	return ApiListAuthCalloutUsersRequest{
		ApiService:    a,
		ctx:           ctx,
		authCalloutId: authCalloutId,
	}
}

// Execute executes the request
//
//	@return AuthCalloutUsersListResponse
func (a *AuthCalloutAPIService) ListAuthCalloutUsersExecute(r ApiListAuthCalloutUsersRequest) (*AuthCalloutUsersListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthCalloutUsersListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthCalloutAPIService.ListAuthCalloutUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/core/beta/auth-callout/{authCalloutId}/users"
	localVarPath = strings.Replace(localVarPath, "{"+"authCalloutId"+"}", url.PathEscape(parameterValueToString(r.authCalloutId, "authCalloutId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			code:  localVarHTTPResponse.StatusCode,
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
